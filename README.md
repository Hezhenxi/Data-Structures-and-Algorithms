# 数据结构和算法 :see_no_evil:
## *旧金山大学 -[数据结构可视化界面](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)*
## 目录


<a name="3060-1621846615933"></a><a name="ybmf-1699837962866"></a>[1.1数据结构](#oth5-1677788272891)

<a name="gevj-1699837962868"></a>[1.1.1关于数据组织](#kmtm-1677788272892)

<a name="vjqk-1699837962870"></a>[1.1.2 关于空间使用](#t37l-1677788272893)

<a name="1tvi-1699837962872"></a>[1.1.3 关于算法效率](#xuzf-1677788272894)

<a name="9hry-1699837962874"></a>[1.1.4 抽象数据类型](#a7es-1677788272895)

<a name="7bac-1699837962876"></a>[  -到底什么是数据结构](#f0ma-1644154694447)

<a name="ow7r-1699837962878"></a>[1.数据对象在计算机中的组织方式](#3qqu-1644154870595)

<a name="twvn-1699837962880"></a>[2.数据对象必定与一系列加在其上的操作相关联](#edky-1644154902635)

<a name="kom7-1699837962882"></a>[1.2 算法](#f0uw-1677788272896)

<a name="ujlk-1699837962884"></a>[1.2.1的定义 Algorithm](#qdly-1677788272897)

<a name="ib2a-1699837962886"></a>[1.2.2 什么是好的算法](#o3rl-1677788272898)

<a name="8mrl-1699837962888"></a>[-空间复杂度S(n)](#dbvt-1644155269309)

<a name="7djt-1699837962890"></a>[-时间复杂度T(n) ](#nult-1644155299003)

<a name="eznw-1699837962892"></a>[1.2.3 复杂度的渐进表示法](#9h6n-1677788272899)

<a name="kx12-1699837962894"></a>[1.3.1 算法应用实列](#qtkj-1677788272900)

<a name="lbzq-1699837962896"></a>[-最大子列和](#iius-1644156631795)

<a name="ahcs-1699837962899"></a>[   算法1 暴力 三层for循环    O(n) = n立方](#jg0h-1644156437963)

<a name="9sdq-1699837962901"></a>[   算法2 改良成两层for循环    O(n) = n平方](#ybbg-1644156457797)

<a name="aoh9-1699837962903"></a>[1.3.2 算法3 分而治之](#tkfc-1677788272901)

<a name="zjy7-1699837962905"></a>[1.3.3 算法4 在线处理](#c1ov-1677788272902)

<a name="sc5e-1699837962907"></a>[2.1 线性表及其实现](#wg8a-1677788272903)

<a name="ytye-1699837962909"></a>[2.1.1多项式引子](#ktmq-1677788272904)

<a name="pnqm-1699837962911"></a>[-什么是线性表： 同类型的数据元素构成有序序列。](#6foh-1644236430675)

<a name="q9xb-1699837962913"></a>[2.1.2 线性表顺序存储实现](#tl9u-1677788272905)

<a name="3bpb-1699837962915"></a>[-初始化：](#3bna-1644237791243)

<a name="unvz-1699837962917"></a>[-查找](#nidh-1644237924264)

<a name="acv9-1699837962919"></a>[2.1.3 线性表顺序存储的插入与删除](#dsxa-1677788272906)

<a name="krfq-1699837962921"></a>[-插入](#ovgs-1644238158698)

<a name="vudf-1699837962923"></a>[-删除](#wfm4-1644238712464)

<a name="mo7t-1699837962925"></a>[2.1.4 线性表的链式存储实现](#ahyd-1677788272907)

<a name="1lib-1699837962927"></a>[-求表长：](#fhlg-1644242726070)

<a name="ydqy-1699837962929"></a>[-查找...](#tnjj-1644243146241)

<a name="picv-1699837962931"></a>[2.1.5 线性表的链式存储实现](#ug1r-1677788272908)

<a name="hbw9-1699837962933"></a>[-插入 ](#w9pb-1644237336937)

<a name="sjrb-1699837962935"></a>[-删除](#urp9-1644243833114)

<a name="szf4-1699837962937"></a>[2.1.6 广义表](#05it-1677788272909)

<a name="tdat-1699837962939"></a>[-多重链表(树、图)](#upvg-1644244080236)

<a name="p1q4-1699837962941"></a>[2.2 堆栈](#bl7d-1677788272910)

<a name="daqv-1699837962943"></a>[2.2.1 什么是堆栈(DFS,回溯)](#k4vb-1677788272911)

<a name="hjd5-1699837962945"></a>[-作用：](#y3km-1644244807631)

<a name="bwue-1699837962947"></a>[-表达式求值?（LIFO）](#q6ki-1644244652399)

<a name="wgof-1699837962949"></a>[-中缀表达式(生活中的表达式)：](#blx6-1644244940694)

<a name="4avh-1699837962951"></a>[-后缀表达式(计算机运算含优先级)](#lniw-1644244978164)

<a name="dncg-1699837962953"></a>[2.2.2 堆栈的顺序存储实现](#ah2g-1677788272912)

<a name="rqr5-1699837962955"></a>[-入栈：](#wrgp-1644246334249)

<a name="p3jm-1699837962957"></a>[2.2.3 堆栈的链式存储实现](#41ag-1677788272913)

<a name="zmrw-1699837962959"></a>[-初始化：](#azgg-1644324516414)

<a name="21sp-1699837962961"></a>[-压栈：](#eev6-1644324911539)

<a name="pain-1699837962963"></a>[-出栈：](#jetm-1644325444995)

<a name="mcg2-1699837962965"></a>[2.2.4 堆栈的应用：表达式求值](#5h58-1677788272914)

<a name="03tm-1699837962967"></a>[-中缀表达式求值(转后缀表达式）](#ykdu-1644326469431)

<a name="wdnc-1699837962969"></a>[-中缀转换成后缀](#uuph-1644327581269)

<a name="rbq8-1699837962971"></a>[2.3.1 队列的顺序存储实现](#bbvf-1677788272915)

<a name="aatb-1699837962973"></a>[-什么是队列Queue(FIFO) ](#j5fs-1644328445710)

<a name="ccae-1699837962975"></a>[-顺环队列判别：](#jatg-1644335249699)

<a name="xl1n-1699837962977"></a>[1.使用额外标记：Size或者tag 域](#0fqp-1644335476431)

<a name="nuxj-1699837962979"></a>[2.仅使用n-1个数组空间 （常用）](#wxur-1644335510849)

<a name="woj2-1699837962981"></a>[-入队：](#pmqe-1644335613325)

<a name="lkas-1699837962983"></a>[-出队：](#kr8c-1644336027627)

<a name="djtn-1699837962985"></a>[2.3.2 队列的链式存储实现](#fvxx-1677788272916)

<a name="v99p-1699837962987"></a>[-单链表实现：](#pmke-1644336400703)

<a name="9lki-1699837962990"></a>[-出队](#s8fi-1699835018323)

<a name="vldm-1699837962992"></a>[2.4 多项式的加减运算实现](#r3nx-1677788272917)

<a name="jqo6-1699837962994"></a>[-采用不带头节点的单向链表，按照指数递减的顺序排列各项](#ktow-1644337425629)

<a name="jadf-1699837962996"></a>[-算法思路：两个指针P1和P2分别指向这两个多项式的第一个节点，不断循环](#luyw-1644339550895)

<a name="epfm-1699837962998"></a>[3.1 什么是树](#cnwo-1677788272918)

<a name="3r3n-1699837963000"></a>[3.1.2 二分查找法（Binary Search）](#vszi-1677788272919)

<a name="ulam-1699837963002"></a>[3.1.3二分查找实现](#kcxc-1677788272920)

<a name="4ouw-1699837963004"></a>[3.1.4 树的定义](#9oui-1677788272921)

<a name="wp9e-1699837963006"></a>[-树的基本术语](#8bmj-1645444077956)

<a name="ijec-1699837963008"></a>[1. 结点的度：结点的子树(仅儿子结点)个树](#pk2a-1645444083342)

<a name="3zmt-1699837963010"></a>[2. 树的度： 树中所有结点中最大的度数](#kooj-1645444153132)

<a name="kwqr-1699837963012"></a>[3. 叶结点：度为0的结点](#drni-1645444218360)

<a name="nklb-1699837963014"></a>[11. 结点的层次：根节点在1层](#9gsy-1645444277084)

<a name="zpcy-1699837963016"></a>[12. 树的深度：最大层次](#7puj-1645444403712)

<a name="isr9-1699837963018"></a>[3.1.5 树的表示](#xbdv-1677788272922)

<a name="nocd-1699837963020"></a>[-数组X](#yhns-1645453382016)

<a name="ffih-1699837963022"></a>[-链表：使结点代码结构一致](#ud8i-1645453549209)

<a name="yeni-1699837963024"></a>[1.儿子-兄弟表示法(左旋转45度)：           ](#6qpk-1645453679575)

<a name="fh1h-1699837963026"></a>[2.双亲表示法：孩子指向双亲（parent）](#ign6-1647845341218)

<a name="bbyf-1699837963028"></a>[3.2.1 二叉树的定义](#ml79-1677788272923)

<a name="uu5w-1699837963030"></a>[-特殊二叉树](#1baq-1645453994717)

<a name="y7lg-1699837963032"></a>[1.斜二叉树    ---等价链表](#fl7g-1645454029441)

<a name="fzkd-1699837963034"></a>[2.完美二叉树 / 满二叉树      --叶子节点满](#v6rh-1645454049742)

<a name="0qkk-1699837963036"></a>[3.完全二叉树   --结点与满二叉树编号位置相同。](#od9j-1645454078512)

<a name="wn8h-1699837963038"></a>[-几个重要性质](#3clv-1645454118085)

<a name="obog-1699837963040"></a>[1.第i层最大结点数： 2的 i-1 次方](#3obh-1645454309964)

<a name="bqwk-1699837963042"></a>[2.深度为K的二叉树最大结点总数：  2的K次方减1](#qpoe-1645454336724)

<a name="thpm-1699837963044"></a>[3.n0 = n2 +1  n2是度为2的非叶结点个数，n0表示度为0（即叶子结点）的个数   ps:度-子树个数](#cp2x-1645454444904)

<a name="jwtz-1699837963046"></a>[-二叉树的抽象数据类型定义](#4v0u-1645455011406)

<a name="rl8h-1699837963048"></a>[1.类型名称： 二叉树](#tagu-1645455020466)

<a name="rrzl-1699837963050"></a>[2.数据对象集： 一个又穷的结点集合](#kanq-1645455032298)

<a name="ce7o-1699837963052"></a>[3.操作集：](#hz54-1645455088206)

<a name="pzfc-1699837963054"></a>[.Boolean IsEmpty(BinTree BT) ](#o74r-1699835495494)

<a name="6i9e-1699837963056"></a>[.void Traversal(BinTee BT)  ; 遍历，按某个顺序访问每个结点 ](#peq4-1645455133062)

<a name="ntbo-1699837963058"></a>[. BinTree CreateBinTree(): 创建一个二叉树](#xorm-1645455229565)

<a name="nuq2-1699837963060"></a>[4.树的遍历通常和算法相关](#nqbl-1645455308856)

<a name="lno2-1699837963062"></a>[.先序/先根遍历   根、左子树、右子树](#lub5-1699835595523)

<a name="mcxg-1699837963064"></a>[.中序 左 根 右](#nplc-1699835599754)

<a name="1sjx-1699837963066"></a>[.后序    左 右  根](#rpml-1699835604145)

<a name="iejv-1699837963069"></a>[. 层次遍历  从上到下，从左到右](#m0un-1699835610234)

<a name="xupj-1699837963071"></a>[3.2.2 二叉树的存储结构](#2alp-1677788272924)

<a name="08wh-1699837963073"></a>[-顺序存储结构](#yxwc-1645456901635)

<a name="le7q-1699837963075"></a>[1.完全二叉树：](#beah-1645456933574)

<a name="gc19-1699837963077"></a>[2.一般二叉树 ](#atjn-1645457415013)

<a name="urkb-1699837963079"></a>[- 链表存储](#z9rr-1645457520347)

<a name="ysbj-1699837963081"></a>[3.3.1 二叉树的遍历(递归-堆栈)](#8prz-1677788272925)

<a name="1kto-1699837963083"></a>[-先序遍历](#sqd4-1645542047590)

<a name="d9yj-1699837963085"></a>[-中序遍历](#zbbh-1645542351803)

<a name="xpgi-1699837963087"></a>[-后续序遍历](#wcx7-1645620627575)

<a name="dszh-1699837963089"></a>[3.3.2 中序非递归遍历](#p5gh-1677788272926)

<a name="c15a-1699837963091"></a>[-中序遍历的非递归遍历算法 （牛逼）](#mvcm-1645621765999)

<a name="dym2-1699837963093"></a>[3.3.3 层序遍历](#y0gg-1677788272928)

<a name="fzxe-1699837963095"></a>[-二叉树遍历的核心问题： 二维结构的线性化](#yiya-1645710174947)

<a name="g2tj-1699837963097"></a>[-队列实现：](#dp48-1645710470408)

<a name="8ugf-1699837963099"></a>[1.从队列取出一个元素](#wjf0-1645711118001)

<a name="jbgp-1699837963101"></a>[2.访问该元素所指结点](#iyau-1645711129851)

<a name="6kxu-1699837963103"></a>[3.若改元素所指结点的左、右孩子结点非空，](#wjzk-1645711151463)

<a name="96vb-1699837963105"></a>[3.3.4 遍历应用的列子](#7j0x-1677788272929)

<a name="kzss-1699837963107"></a>[-输出二叉树中的叶子结点](#cxle-1645620638879)

<a name="8uqj-1699837963109"></a>[- 求二叉树的高度   ](#oasx-1645711968602)

<a name="fbvo-1699837963111"></a>[-二元运算表达式数及其遍历](#jjrf-1645712590444)

<a name="d3vu-1699837963113"></a>[-由两种遍历序列确定二叉树](#rqfj-1645713283207)

<a name="pkbj-1699837963115"></a>[4.1.1 二叉搜索树及查找](#o2qw-1677788272930)

<a name="xg9a-1699837963117"></a>[-二叉搜索树的查找操作Find](#yefy-1646574780329)

<a name="hdjd-1699837963119"></a>[-尾递归都可以用循环实现](#d9oj-1646575119810)

<a name="ev43-1699837963121"></a>[-查找最大和最小元素](#m4z6-1646575431174)

<a name="e7f2-1699837963123"></a>[4.1.2 二叉搜索树的插入](#lehm-1677788272931)

<a name="h5as-1699837963125"></a>[4.1.3 二叉搜索树的删除](#e7rv-1677788272932)

<a name="jwqh-1699837963127"></a>[-删除的是叶子结点，](#0077-1646577661966)

<a name="qso4-1699837963129"></a>[-只有一个孩子结点：](#qatj-1646577728059)

<a name="rdrl-1699837963131"></a>[-有左右两颗子树：](#ka9m-1646577770541)

<a name="qjp7-1699837963133"></a>[4.2.1 平衡二叉树](#vszn-1677788272933)

<a name="h1uu-1699837963135"></a>[-什么是平衡二叉树](#p98v-1646580853913)

<a name="lxqd-1699837963137"></a>[1.深度和平均查找长度ASL 最小的二叉树结构](#ex8z-1646580859710)

<a name="ozgu-1699837963139"></a>[2.平衡因子  ：左右子树高度差 BF(T) = H左 - H 右](#vgir-1646581014297)

<a name="8fmh-1699837963141"></a>[3.平衡二叉树： （AVL树）](#rmzf-1646581088479)

<a name="shmc-1699837963143"></a>[4.2.2 平衡二叉树的调整 （保证每个结点平衡因子| BF(T)|<=1）](#utk5-1677788272934)

<a name="0cp6-1699837963145"></a>[-右单旋：](#kuqb-1646581501829)

<a name="utbg-1699837963147"></a>[-左单旋：](#wa6j-1646582121494)

<a name="ocl2-1699837963149"></a>[-LR旋转：](#jmg3-1646582185738)

<a name="tcin-1699837963151"></a>[-RL旋转：](#dd9e-1646581849728)

<a name="zzis-1699837963153"></a>[5.1.1 什么是堆](#fkbx-1677788272935)

<a name="td3f-1699837963155"></a>[-优先队列（Priotiry Queue）](#8teh-1646654863957)

<a name="lxpv-1699837963157"></a>[-实现：](#kvg3-1646654971440)

<a name="hmva-1699837963160"></a>[1.数组： 插入-元素总是插入尾部    删除-查找最大（或最小）关键字，从数组中删去要移动的元素](#eckj-1646654974527)

<a name="0gdf-1699837963162"></a>[2.链表： 插入-元素总是插入链表的头部  删除-查找最大（或最小）关键字，删去结点](#upag-1646655035201)

<a name="owlk-1699837963164"></a>[3.有序数组： 插入-找到合适的位置移动元素并插入    删除-删去最后一个元素](#ivi1-1646582654691)

<a name="2t9n-1699837963166"></a>[4.有序链表：插入-找到合适的位置插入元素  删除-删除首元素或最后元素](#lwz7-1646655242369)

<a name="rzfo-1699837963168"></a>[-堆的两个特性：](#b3fy-1646655452745)

<a name="birc-1699837963170"></a>[1.结构性-用数组表示的完全二叉树](#n5ng-1646655472739)

<a name="3dwj-1699837963172"></a>[2.有序性：任一节点的关键字是其子树所有结点的最大值（或最小值）](#udr3-1646655488799)

<a name="xlj2-1699837963174"></a>[5.1.2堆的插入](#eghz-1677788272936)

<a name="fhqc-1699837963176"></a>[-最大堆的创建](#k7eg-1646655793805)

<a name="8ikb-1699837963178"></a>[-将新增结点插入到其父节点到根节点的有序序列中](#vzbs-1646655909501)

<a name="fuyb-1699837963180"></a>[5.1.3 堆的删除](#5p6t-1677788272937)

<a name="ld7p-1699837963182"></a>[5.1.4 堆的建立](#1gp9-1677788272938)

<a name="z81d-1699837963184"></a>[-堆排序](#ccis-1646658181713)

<a name="foyi-1699837963186"></a>[5.2.1 哈夫曼树与哈夫曼编码  ](#upwp-1677788272939)

<a name="xjrn-1699837963188"></a>[-压缩字节！！根据出现频率设置权重，优化查找。](#chll-1646659093007)

<a name="vpt9-1699837963190"></a>[-最优二叉树/哈夫曼树： WPL 最小的二叉树](#cbrh-1646659399289)

<a name="csxv-1699837963192"></a>[5.2.2 哈夫曼树的构造](#oaxy-1677788272940)

<a name="nhpf-1699837963194"></a>[-如何选取两个最小的--利用最小堆](#tcvt-1646660738563)

<a name="kph0-1699837963196"></a>[-哈夫曼树的特点：](#kwx2-1646660786575)

<a name="cnjw-1699837963198"></a>[1.没有度为1的结点；](#vney-1646660929619)

<a name="y1qz-1699837963200"></a>[2.n个叶子结点的哈夫曼树共有2n-1个结点；](#rmhw-1646660939676)

<a name="c28r-1699837963202"></a>[3.哈夫曼树的任意非叶子结点的左右子树交换后仍是哈夫曼树；](#yg50-1646661094503)

<a name="yog3-1699837963204"></a>[4.同一组权值，可存在不同构的两颗哈夫曼树。WPL仍一样。](#3vek-1646661132877)

<a name="ib0b-1699837963206"></a>[5.2.3 哈夫曼编码(存储空间最小/代价最小wpl)](#wquu-1677788272942)

<a name="a0xy-1699837963208"></a>[5.3.1 集合的表示与查找](#yfwk-1677788272943)

<a name="m7dm-1699837963210"></a>[-集合运算：交，并，补，差，判定一个元素是否属于某一个集合](#amg2-1648133035306)

<a name="e6cu-1699837963212"></a>[-并查集：集合并，查某元素属于什么集合 （A连接B,B连接C, A一定与C连接）传递性](#opn5-1648133351996)

<a name="vvks-1699837963214"></a>[-并查集合的存储如何实现](#fh2i-1648133386745)

<a name="0ecb-1699837963216"></a>[1.可以用树结构表示集合，每个结点代表一个集合元素](#4e2s-1648133451444)

<a name="zuwd-1699837963218"></a>[2.双亲表示法：子结点指向父结点（有点像DB部门设计）](#blca-1648133486851)

<a name="g3g8-1699837963220"></a>[-存储形式　：](#5rpq-1648133577547)

<a name="hxiy-1699837963222"></a>[1.链表](#errq-1648133592538)

<a name="s89r-1699837963224"></a>[2.数组：](#o5ma-1648133596331)

<a name="ixg5-1699837963226"></a>[5.3.2 集合的并运算](#lpay-1677788272944)

<a name="ftuq-1699837963228"></a>[6.2.1 DFS （递归or栈）](#jr61-1678812601851)

<a name="88kw-1699837963230"></a>[6.2.2 BFS（出队列将关联节点压队列）](#tzff-1678568020093)

<a name="lgj4-1699837963232"></a>[-代码类似树的层序遍历，将选中的元素压队，出队时将图相连的元素入队。](#yxtm-1678812916063)

<a name="trfl-1699837963234"></a>[6.2.3 为什么需要两种遍历](#6fdp-1684180430795)

<a name="nhma-1699837963236"></a>[-迷宫出口靠近左上角--广度优先高效 ，圆圈型遍历](#dwfj-1684180472085)

<a name="wret-1699837963238"></a>[-迷宫出口在右下角--深度有限高效，横向型遍历](#ybea-1684180535099)

<a name="mtfk-1699837963240"></a>[6.2.4 图连不通怎么办](#f6be-1684355826642)

<a name="kacn-1699837963242"></a>[6.2.5 拯救007 ](#ivj5-1684355845184)

<a name="lhxt-1699837963244"></a>[6.2.6 六度空间理论 BFS](#xria-1684355871851)

<a name="rvr3-1699837963246"></a>[11.1.2 散列表](#1luf-1677788272945)

<a name="je1f-1699837963249"></a>[-散列思想：](#fb0g-1648371904573)

<a name="vvyf-1699837963251"></a>[1.哈希函数计算出对应的函数值（数字），作为对象的存储地址。](#ffdy-1648371914096)

<a name="qh88-1699837963253"></a>[2.可能不同的函数值会映射到同一个散列地址上，需要某种解决冲突的策略](#2now-1648371957139)

<a name="gov2-1699837963255"></a>[11.4 散列表的性能分析](#phu8-1677788272946)

<a name="h2mj-1699837963257"></a>[-事件复杂度O(1)](#rey6-1648371277368)

<a name="yj7n-1699837963259"></a>[-负载因子/装填因子(0.5<n<0.85)](#kxlv-1648371403694)

<a name="u2jw-1699837963261"></a>[-随机查找](#nuwh-1648371448540)

<a name="nupl-1699837963263"></a>[-hash冲突解决](#9cz3-1648371607274)

<a name="xhpk-1699837963265"></a>[1.开放地址法：](#qsys-1648371608637)

<a name="hb0b-1699837963267"></a>[2.分离链接法：HashMap](#3seq-1648371648874)

<a name="8wnr-1699837963269"></a>[9.1.1排序算法](#084u-1677788272947)

<a name="ym9c-1699837963271"></a>[9.1.2 冒泡排序(每轮最大往前冒泡)](#g3wd-1677788272948)

<a name="klkt-1699837963273"></a>[9.1.3 插入排序(打牌)](#i0gw-1677788272949)

<a name="uvpe-1699837963275"></a>[9.1.3.1 快速排序(分治算法)](#7n4a-1677788272950)

<a name="0bsy-1699837963277"></a>[ -递归的两个条件：](#evi5-1699837774968)

<a name="dltt-1699837963279"></a>[1.基线条件 ](#v1wk-1699837806719)

<a name="xkmt-1699837963281"></a>[ 2.递归条件](#ccbf-1699837837267)

<a name="vkms-1699837963283"></a>[-分治](#s5pr-1699837813602)

<a name="nvjn-1699837963285"></a>[1.找到基准值 ](#ns0a-1699837828819)

<a name="kf8k-1699837963287"></a>[2.将问题切割成相同的小块，逐个解决 ](#uoqo-1699837831242)

<a name="olfd-1699837963289"></a>[3.将结果合并](#w6tb-1699837833288)

<a name="15ll-1699837963291"></a>[9.1.4 时间复杂度下界(逆序对)](#nlyn-1677788272951)

<a name="amv3-1699837963293"></a>[-逆序对  ，冒泡和插入每次交换只能消除一个逆序对！](#ezs9-1646827707722)

<a name="baff-1699837963295"></a>[-定理： 任意N个不同元素组成的序列平均具有 N（N-1）/4 个逆序对。](#suoz-1646827870918)

<a name="pik5-1699837963297"></a>[9.2 希尔排序](#6yzg-1677788272952)

<a name="o5ht-1699837963299"></a>[9.3.1 选择排序](#q9xc-1677788272953)

<a name="4ksv-1699837963301"></a>[9.3.2 堆排序](#dykg-1677788272954)

<a name="paa9-1699837963303"></a>[leetcode](#kesf-1677788272955)

<a name="doyo-1699837963305"></a>[1190 反转字符串](#aidz-1677788272956)

<a name="voy5-1699837963307"></a>[BM8  链表中倒数第N个节点 easy](#5npw-1677788272957)

<a name="23dt-1699837963309"></a>[BM15 删除有序链表中重复的元素-I      easy](#yt1h-1677788272959)



<a name="oth5-1677788272891"></a>**1.1数据结构**

<a name="kmtm-1677788272892"></a>**1.1.1关于数据组织**

<a name="btmr-1644057084060"></a>  数据组织的一种形式，

<a name="iqnx-1644057210187"></a>**解决问题方法的效率，跟数据的组织方式有关**（图书馆如何存放图书方便插入和查找）

<a name="t37l-1677788272893"></a>**1.1.2 关于空间使用**

<a name="msoh-1644057292063"></a>递归与for循环10万次比较。递归吃的空间多，直接内存爆了

<a name="wcxe-1644057444026"></a>**解决问题方法的效率，跟空间的利用效率有关**

<a name="xuzf-1677788272894"></a>**1.1.3 关于算法效率**

<a name="vvvo-1644063806277"></a>给多项式在给定点x处的值 f(x)= a0 +a1x+ ....+ AnXn    P+=（a[i]\*pow(x,i)）

<a name="uqfj-1644063786484"></a>**解决问题方法的效率，跟算法的巧妙程度有关  （a+x(a1+x(...an-1+x(an)...))**每层提取一个公因子x出来，不用幂运算-秦九绍算法）

<a name="a7es-1677788272895"></a>**1.1.4 抽象数据类型**

<a name="f0ma-1644154694447"></a>  **-到底什么是数据结构**

<a name="3qqu-1644154870595"></a>**1.数据对象在计算机中的组织方式**

<a name="lina-1644154884139"></a> 逻辑结构

<a name="vlrn-1644154889146"></a> 物理存储结构

<a name="edky-1644154902635"></a>**2.数据对象必定与一系列加在其上的操作相关联**

<a name="lhxa-1644154928740"></a>  完成这些操作所用的方法就是算法

<a name="p4ye-1644155058557"></a><a name="f0uw-1677788272896"></a>**1.2 算法**

<a name="qdly-1677788272897"></a>**1.2.1的定义 Algorithm**

<a name="ojta-1644155154219"></a> 计算机中的理论定义（略）

<a name="o3rl-1677788272898"></a>**1.2.2 什么是好的算法**

<a name="dbvt-1644155269309"></a>**-空间复杂度S(n)**

<a name="5gvv-1699833736291"></a> **占用存储单元的长度    :**递归耗费内存空间大

<a name="nult-1644155299003"></a>**-时间复杂度T(n)** 

<a name="gktm-1699833739012"></a> **耗费时间的长度：多**项式子 1.T(n)=C1N次方+ c2n      2.cn 次乘法

<a name="uevo-1644337360091"></a>ps:计算机乘除法比加减法耗时，加法复杂度省略

<a name="9h6n-1677788272899"></a>**1.2.3 复杂度的渐进表示法**

<a name="thol-1644155741526"></a>T(n)=O(f(n))   **1 < logn < n < n logn < n平方 < n立方 < n！**

<a name="ecdf-1644156048145"></a>**复杂度分析小窍门**

<a name="hpmi-1644156062124"></a>**T1(n)+T2(n) = max(O(f1(n)), O(f2(n)) )**    if else 时间复杂度 = 分支条件代码最大复杂度

<a name="nldv-1644156127252"></a>**T1(n)\*T2(n) = O(f1(n) \* f2(n))**       for循环时间复杂度 = 次数\* 循环体代码复杂度

<a name="uute-1644156348793"></a><a name="qtkj-1677788272900"></a>**1.3.1 算法应用实列**

<a name="iius-1644156631795"></a>**-最大子列和**

<a name="jg0h-1644156437963"></a>   **算法1 暴力 三层for循环    O(n) = n立方**

<a name="ybbg-1644156457797"></a>   **算法2 改良成两层for循环    O(n) = n平方**

<a name="tkfc-1677788272901"></a>**1.3.2 算法3 分而治之**

<a name="48aq-1644156770265"></a>先分后治理，最后处理边界问题 。递归分治，空间换时间

<a name="em9q-1644156794948"></a>O(n) = n logn   数学公式推导

<a name="c1ov-1677788272902"></a>**1.3.3 算法4 在线处理**

<a name="di4r-1644157266803"></a>一次for循环搞定 （具体该算法的逻辑实现）

<a name="lnus-1644157276285"></a>O(n) = n

<a name="eapl-1644157347419"></a><a name="wg8a-1677788272903"></a>**2.1 线性表及其实现**

<a name="ktmq-1677788272904"></a>**2.1.1多项式引子**

<a name="indz-1644236854229"></a>线性表的表示

<a name="6foh-1644236430675"></a>**-什么是线性表： 同类型的数据元素构成有序序列。**

<a name="z4zv-1644237147930"></a><a name="tl9u-1677788272905"></a>**2.1.2 线性表顺序存储实现**

<a name="2xue-1645458627558"></a>typedef struct LNode \*List;

<a name="ssbs-1644237280112"></a>struct LNode{

<a name="ckqc-1644237304073"></a>ElementType Data[MAXSIZE];  //数组

<a name="f6yy-1644237327640"></a>int Last;

<a name="5wke-1644237305417"></a>}

<a name="zyaj-1645458864962"></a>struct LNode L;

<a name="h7j4-1645458874894"></a>List PtrL；

<a name="qyst-1644237351752"></a>操作集：初始化、插入、删除、查找、返回长度

<a name="3bna-1644237791243"></a>**-初始化：**

<a name="phje-1699833996926"></a>List MakeEmpty(){

<a name="qyvk-1644237835622"></a>List PtrL:

<a name="xa6j-1644237848553"></a>Ptrl = (List) malloc( sizeof(Struct LNode));

<a name="bgze-1644237887463"></a>Ptrl -> Last = -1;

<a name="kuvx-1644237908657"></a>return Ptrl;

<a name="02ko-1644237836657"></a>}

<a name="nidh-1644237924264"></a>**-查找**

<a name="bygp-1699833998422"></a>：int Find(ElementType X, List Ptrl){

<a name="qbgd-1644237953200"></a>int i = 0;

<a name="equn-1644237968952"></a>while( i<= Ptrl->Last  && Ptrl->Data[i]!=x)

<a name="xc0c-1644238027569"></a>i++;

<a name="278s-1644238031313"></a>if( i>PtrL->Last) return -1;

<a name="9fzq-1644238081592"></a>else return i;

<a name="yd8a-1644237959080"></a>}

<a name="wcev-1644237550649"></a><a name="dsxa-1677788272906"></a>**2.1.3 线性表顺序存储的插入与删除**

<a name="ovgs-1644238158698"></a>**-插入**

<a name="fxc2-1699834034131"></a>：void insert(ElementType X,int i, List PtrL){

<a name="mzib-1644238256495"></a>int j:

<a name="nlsh-1644238270521"></a>if( PtrL->Last == MAXSIZE-1){

<a name="hmiu-1644238313472"></a>print( "表满“)；

<a name="qeod-1644238332609"></a>return;

<a name="vqqy-1644238309904"></a>}

<a name="ewhc-1644238336241"></a>if( i< 1 || i >Ptrl->Last + 2 )  // +2出现一个空位置

<a name="91om-1644238460934"></a>printf(" 位置不合法")

<a name="fusu-1644238496208"></a>return；

<a name="gogl-1644238257281"></a>for( j = PtrL -> Last: j>- i-1; j--)

<a name="zmyu-1644238535367"></a>PtrL->Data[j+1] = PtrL->Data[j];

<a name="3csp-1644238572742"></a>PtrL->Data[i-1] = X;

<a name="s8w6-1644238663834"></a>PtrL->Last++;

<a name="uev8-1644238696610"></a>return;

<a name="bem4-1644238505977"></a>}

<a name="ayoz-1644238709463"></a><a name="wfm4-1644238712464"></a>**-删除**

<a name="ekxm-1699834041863"></a> void delete(int i, List Ptrl){

<a name="kkal-1644238778727"></a>int j;

<a name="dxdc-1644239064219"></a>if( i<1 || i > Ptrl->Last+1){

<a name="a1om-1644239261388"></a>print("不存在第%d个元素"，i)；

<a name="yrhy-1644239283728"></a>return;

<a name="fbsz-1644239119995"></a>}

<a name="jlun-1644239287384"></a>for(j= i; j<=Ptrl->Last; j++)

<a name="0uze-1644239541484"></a>PtrL->Data[j-1] = PtrL-> Data[j];

<a name="ijiu-1644239676023"></a>PtrL->Last--;

<a name="3ana-1644239702943"></a>return;

<a name="k65c-1644238981578"></a>}

<a name="tfos-1644242272473"></a><a name="ahyd-1677788272907"></a>**2.1.4 线性表的链式存储实现**

<a name="wzdf-1644242312244"></a>不要求逻辑上相邻的两个元素物理上也相邻: 通过”链“建立逻辑关系

<a name="ygxk-1644242424821"></a>☐ 插入、删除不需要移动数据元素，只需要修改”链“；

<a name="vlhp-1644242637172"></a>typedef struct LNode \*List;

<a name="wz0a-1644242661799"></a>struct LNode{

<a name="epi6-1644242668719"></a>ElementType Data;

<a name="jrmv-1644242679750"></a>List Next;

<a name="qbkm-1644242671464"></a>}

<a name="hfpp-1644242205816"></a>struct Lnode L;

<a name="yge7-1644242710309"></a>List PtrL;

<a name="fhlg-1644242726070"></a>**-求表长：**

<a name="2xtm-1699834078983"></a>int Length( List PtrL){

<a name="hi0p-1644242816459"></a>List p = PtrL;

<a name="a6ce-1644242826502"></a>int j = 0;

<a name="qqpk-1644242832446"></a>while( p){

<a name="yar0-1644242846197"></a>p = p->Next;  //next = null 时，跳出循环；

<a name="6ziu-1644242877072"></a>j++;

<a name="jrjh-1644242851405"></a>}

<a name="l8jm-1644242881733"></a>return j;

<a name="3eiq-1644242818504"></a>}

<a name="tnjj-1644243146241"></a>**-查找...**

<a name="ug1r-1677788272908"></a>**2.1.5 线性表的链式存储实现**

<a name="w9pb-1644237336937"></a>**-插入** 

<a name="vd4u-1644243388323"></a> 1）   先构造一个新节点，用s指向

<a name="elto-1644243408774"></a>2）先 s->Next = p->Next;

<a name="8br9-1644243429373"></a>3)   后 p->Next = s;

<a name="urp9-1644243833114"></a>**-删除**

<a name="zapv-1699834102815"></a> s = p->Next;

<a name="xrrc-1644243883182"></a>  p->Next = s-Next;

<a name="nxma-1644243903013"></a>free(s);   //释放内存

<a name="rrlz-1644243920317"></a>return Ptrl;

<a name="05it-1677788272909"></a>**2.1.6 广义表**

<a name="upvg-1644244080236"></a>**-多重链表(树、图)**

<a name="kavg-1644244172349"></a>多重链表中节点的**指针域会有多个，**如**Next**和**SubList**两个指针域;

<a name="qxdy-1644244167099"></a>但是包含两个指针域的链表并不一定是多重链表，比如 **双向链表不是多重链表**。

<a name="oiw4-1644244220710"></a>**树、图**这样相对复杂的数据结构都可以**采用多重链表的方式实现存储**。

<a name="gfht-1644244604550"></a><a name="bl7d-1677788272910"></a>**2.2 堆栈**

<a name="k4vb-1677788272911"></a>**2.2.1 什么是堆栈(DFS,回溯)**

<a name="y3km-1644244807631"></a>**-作用：**

<a name="6arg-1699834341303"></a>**函数调用及递归**（层层存储，后倒回来计算）**、表达式求值**等 深度优先搜索（DFS）、回溯算法

<a name="q6ki-1644244652399"></a>**-表达式求值?（LIFO）**

<a name="uwcp-1644244860964"></a> 运算数

<a name="miz2-1644244937135"></a>运算符号

<a name="blx6-1644244940694"></a>**-中缀表达式(生活中的表达式)：**

<a name="vp9n-1699834354800"></a>运算符号位于两个运算数之间：a+b\*c-d/e

<a name="lniw-1644244978164"></a>**-后缀表达式(计算机运算含优先级)**

<a name="zvfy-1699834356415"></a>运算符号位于两个运算数之后：abc\*+de/- //由制定的规则 出入栈 生成后缀表达式。

<a name="g1td-1644245315623"></a>例子：62、3-42\*+ = ？

<a name="ceye-1644245329629"></a>后缀表达式求值策略：从左往右扫描，逐个处理运算数和运算符号

<a name="vjya-1644245393711"></a>1.遇到运算数怎么办？ 

<a name="zoti-1644245406891"></a>2.遇到运算符号怎么办？

<a name="6wh2-1644245464667"></a>-需要顺序存储运算数，遇到运算符号时倒序输出两个元素运算----**LIFO 栈结构 Stack**

<a name="ap0n-1644245627800"></a><a name="ngdl-1644245629909"></a>**堆栈的抽象数据类型描述**

<a name="uu67-1644245651212"></a>**Stack:** 只在一端（栈顶，**Top**）做插入、删除

<a name="7ubm-1644245710677"></a>插入数据：入栈 **Push**

<a name="jxza-1644245747245"></a>删除数据：出战 **Pop**

<a name="r6dp-1644245759764"></a>后入先出： **LIFO**

<a name="uvep-1644245729236"></a><a name="ah2g-1677788272912"></a>**2.2.2 堆栈的顺序存储实现**

<a name="dmgg-1644246201086"></a>typedef struct SNode \*Stack;

<a name="ff65-1644246223413"></a>struct SNode{

<a name="7md8-1644246230237"></a>ElementType Data[MaxSize]; //一维数组

<a name="mnci-1644246243780"></a>int Top;  //栈顶

<a name="w7i6-1644246231437"></a>}

<a name="wrgp-1644246334249"></a>**-入栈：**

<a name="q4qq-1699834496130"></a>void Push(Strck PtrS, ElementType item){

<a name="uoeo-1644246361261"></a>if( PtrS->Top == MaxSize -1)

<a name="zosw-1644246383886"></a>printf("堆栈满")；return;

<a name="gu5h-1644246735477"></a>else

<a name="yfzo-1644246742341"></a>PtrS->Data[++(PtrS->Top)] = item;

<a name="nmtf-1644246773798"></a>return;

<a name="yoo0-1644246727957"></a>}

<a name="41ag-1677788272913"></a>**2.2.3 堆栈的链式存储实现**

<a name="kf3q-1644245974655"></a>单链表/链栈  Top应该在表头 A(栈顶)->B(栈第一个元素)->C  **PS：此类结构不一定按栈来操作，但栈操作 可 next->新元素（再改变头节点位置） 或 新元素.next = node（这样空栈时头结点会占一个坑位：不适合有头结点的空栈）**

<a name="m3yb-1644326322630"></a>// 链尾做Top出栈删除时找不到top的上一个元素，无指针指向上一个元素

<a name="qakj-1644324372075"></a>typedef struct Node \*Stack;

<a name="wmkf-1644324396564"></a>struct SNode{

<a name="uqd7-1644324416573"></a>ElementType Data;  // 链表没有定义大小

<a name="czkj-1644324450039"></a>struct SNode \*Next;

<a name="ytfe-1644324443046"></a>}

<a name="azgg-1644324516414"></a>**-初始化：**

<a name="sexa-1699834538483"></a>Stack CreateStack(){

<a name="geck-1644324535811"></a>Stack S;     //头节点，Top作用，实际第一个元素式S->Next

<a name="e0cj-1644324543499"></a>S = (Stack) malloc(sizeOf( struct Snode));

<a name="qgjy-1644324630004"></a>s->Next = null;

<a name="vd1j-1644324646212"></a>return S;

<a name="cloa-1644324536812"></a>}

<a name="nccr-1644324793047"></a>int IsEmpty(Stack S){

<a name="yfd5-1644324804388"></a>return ( S->Next == null );

<a name="zuyx-1644324805363"></a>}

<a name="eev6-1644324911539"></a>**-压栈：**

<a name="wkax-1699834534113"></a> void Push(ElementType item， Stack S){         // C++函数参数是值传递，**java函数参数是副本（直接用头结点方式，改对象next指向，应该直接操作对象，而不是给副本重新赋对象地址），**

<a name="40rx-1647714156790"></a>**对本值操作需要搞清楚，形参重新赋值地址，不会改变实参地址，可返回对象地址赋值给实参（画蛇添足）；最完美的还是下面的写法，牛逼！！！灵活应用吧**

<a name="105i-1644325063727"></a>struct SNode \*TmpCell;

<a name="ge9x-1644325088892"></a>TmpCell = (struct SNode \*)malloc(sizeof(struct Snode));

<a name="whvz-1644325184306"></a>TmpCell->Element = item;

<a name="23f7-1644325204123"></a>TmpCell->Next = S->Nxet;   //指针对指针,交换指向

<a name="ygmu-1644325266348"></a>S->Next = TmpCell;            // 指针对类型，指向

<a name="zlit-1644325064724"></a>}

<a name="jetm-1644325444995"></a>**-出栈：**

<a name="3hgr-1699834532312"></a> ElementType Pop(Stack S){

<a name="vfgc-1644325473036"></a>struct Snode \*FirstCell;

<a name="0e63-1644325501596"></a>ElementTyupe TopElem;

<a name="rf0d-1644325511747"></a>if(  IsEmpty( S ))

<a name="rqiz-1644325545508"></a>printf("堆栈空")； return Null；

<a name="ipxu-1644325473900"></a>       else

<a name="y6fb-1644325592190"></a>FirstCell = S->Next;

<a name="dvh4-1644325609164"></a>S->Next = FirstCell-->Next;

<a name="luua-1644325775148"></a>TopElem = FirsCell -> Element;

<a name="fnnu-1644325796532"></a>free(FirstCell);

<a name="gugs-1644325809753"></a>return TopElem;           //  S -> 1(X) -> 2-> 3

<a name="glyz-1644325576161"></a>}

<a name="ruxs-1644326443408"></a><a name="5h58-1677788272914"></a>**2.2.4 堆栈的应用：表达式求值**

<a name="ykdu-1644326469431"></a>**-中缀表达式求值(转后缀表达式）**

<a name="gxjo-1644326564755"></a>基本策略：将中缀表达式转换为后缀表达式，然后求值

<a name="sot7-1644326594496"></a>how:  2+9/3-5    >>>  293/+5-

<a name="0gbx-1644326820769"></a>2 9 3 293/   293/+  293/+5-

<a name="jqjo-1644326753155"></a>+ /    + - 

<a name="g8lz-1644327210047"></a>("-"号要入栈，比较优先级,优先级大的先出，同级先入先出)       

<a name="1yzq-1644326626217"></a>1.运算数相对顺序不变

<a name="emv5-1644326641983"></a>2.运算符号顺序发生改变  

<a name="zwwz-1644326656397"></a>>需要存储“等待中”的运算符号

<a name="dffu-1644326686276"></a>>要将当前运算符号与 ”等待中“ 的最后一个运算符号比较

<a name="sxep-1644327359759"></a>括号情况下：

<a name="ebeo-1644327369230"></a>a\*（b+c）/d       

<a name="gv4r-1644327404087"></a>abc  )    abc+  /   abc\*d  abc\*d/

<a name="mtum-1644327407695"></a>\*(+         \*            / 

<a name="nb0r-1644327580877"></a><a name="uuph-1644327581269"></a>**-中缀转换成后缀**

<a name="yoyx-1644327597138"></a>从头到尾读取中缀表达式的每个对象，对不同对象按不同情况处理。

<a name="iszy-1644327648582"></a>>**运算数**：直接输出

<a name="drgj-1644327663566"></a>>**左括号**：压入堆栈

<a name="pil3-1644327680863"></a>> **右括号**：将**栈顶的运算符弹出并输出**，**直到遇到左括号**（出栈不输出）//右括号不入栈，用来消左括号）

<a name="ltzy-1644327734675"></a>> **运算符**： 

<a name="rgcj-1644327750441"></a>若**优先级大于栈顶元素**时，则**压栈**

<a name="nojy-1644327772392"></a>若**优先级小于栈顶元素**时，则**将栈顶元素弹出并输出**：再比较新的栈顶运算符，**直到该运算符大于栈顶运算符优先级为止**，然后将**该运算符压栈**

<a name="y25r-1644327868870"></a>> 若个对象**处理完毕**，则把堆栈中存留的**运算符一并输出**

<a name="sz4h-1644328414991"></a><a name="bbvf-1677788272915"></a>**2.3.1 队列的顺序存储实现**

<a name="j5fs-1644328445710"></a>**-什么是队列Queue(FIFO)** 

<a name="bb3a-1699834891921"></a>**只能在一端插入，另一端删除**

<a name="5y4b-1644328504370"></a>插入：**入队列 （AddQ）**

<a name="ix8k-1644328519675"></a>删除：**出队（DeleteQ）**

<a name="q930-1644328537947"></a>**先来先服务**

<a name="k94c-1644328549955"></a>**先进先出 ：FIFO**

<a name="ijfm-1644334854288"></a><a name="nozu-1644328560522"></a>数据对象集：一个有0个或者多个元素的有穷线性表

<a name="mbfi-1644334899805"></a>操作集：生成队列，判断队列是否已满，入队，队列为空，出队（将头元素从队列中删除并返回）

<a name="sljm-1644335008679"></a>struct QNode{

<a name="iwv0-1644335051182"></a>ElementType Data[ MaxSize ];  //一维数组

<a name="utbo-1644335068424"></a>int rear;    //尾元素

<a name="coue-1644335072860"></a>int front;  //头元素

<a name="qg07-1644335051896"></a>}；

<a name="f4q8-1644335127384"></a>typedef struct QNode \*Queue;

<a name="orsm-1644335249523"></a><a name="jatg-1644335249699"></a>**-顺环队列判别：**

<a name="jxzn-1699834926286"></a>满和空时, Rear 和Front 位置相同，怎么判别？

<a name="0fqp-1644335476431"></a>**1.使用额外标记：Size或者tag 域**

<a name="wxur-1644335510849"></a>**2.仅使用n-1个数组空间 （常用）**

<a name="87is-1644335602535"></a><a name="pmqe-1644335613325"></a>**-入队：**

<a name="cmfm-1699834939050"></a> void AddQ( Queue PtrQ, ElementType item) {

<a name="xfss-1644335656704"></a>if( (PtrQ->rear+1)% MaxSize == PtrQ->front) //**仅使用n-1个数组空间** 

<a name="ezku-1644335775409"></a>printf( "队列满")；

<a name="2yng-1644335791879"></a>return;

<a name="gokl-1644335801341"></a>Ptr!->rear = (PtrQ-rear+1)% MaxSize;  //保证 rear值<=MaxSize;

<a name="rybl-1644335897799"></a>PtrQ->Data[ PtrQ->rear] = item;

<a name="jvtf-1644335657565"></a> }

<a name="kr8c-1644336027627"></a>**-出队：**

<a name="ou18-1699834945765"></a> ElementType DeleteQ(Queue PtrQ){

<a name="tgri-1644336053280"></a>if(PtrQ->front == PtrQ->near)

<a name="p9gv-1644336087148"></a>printf("队列空")

<a name="wwl7-1644336098992"></a>return ERROR;

<a name="ydf7-1644336101856"></a>else 

<a name="ovnd-1644336165854"></a>PtrQ->front = (PtrQ->front+1)% MaxSize;

<a name="hixw-1644336213824"></a>return Ptrq->Data[ PtrQ->front ];

<a name="30to-1644336054001"></a>}

<a name="0ill-1644336276218"></a><a name="fvxx-1677788272916"></a>**2.3.2 队列的链式存储实现**

<a name="pmke-1644336400703"></a>**-单链表实现：**

<a name="sqpz-1699835038335"></a>同理tail尾不能做删除，所以front 放 头，A（front出队）->b->C(rear 入队)

<a name="ca6p-1644336458764"></a>struct Node{

<a name="sk0x-1644336524390"></a>ElementType Data;

<a name="gm7o-1644336532547"></a>struct Node \*Next;

<a name="6xjd-1644336525019"></a>};

<a name="i8jm-1644336545787"></a>struct QNode{        //链队列结构

<a name="wrlf-1644336555939"></a>struct Node \*rear;

<a name="dpxj-1644336631835"></a>struct Node \*front;

<a name="v9n6-1644336562011"></a>};

<a name="yhvj-1644336657655"></a>typeddef struct QNode \*Queue;

<a name="rmlq-1644336677546"></a>Queue PtrQ;

<a name="srv4-1644336782808"></a><a name="g6x9-1644336788524"></a>不带头节点的链式队列 

<a name="s8fi-1699835018323"></a>**-出队**

<a name="zh2r-1644336802532"></a>ElementType DeleteQ( Queue PtrQ){

<a name="whb7-1644336829405"></a>struct Node \*FrontCell;

<a name="irva-1644336846006"></a>ElementType FrontElement;

<a name="dpfv-1644336854918"></a>if( PtrQ->front == NULL)

<a name="vjtc-1644336876925"></a>print("队列空")；return ERROR；

<a name="7rev-1644336946257"></a>FrontCell = PtrQ->front;

<a name="2gl0-1644336961973"></a>if( PtrQ->front == PtrQ->rear)       //队列只有一个元素--不带头节点

<a name="jziu-1644336988828"></a>PtrQ->front = ptrQ->rear = NULL;

<a name="rbqc-1644337035492"></a>else

<a name="dbkw-1644337038470"></a>PtrQ->front = PtrQ->front->Next;

<a name="n0rh-1644337066973"></a>FrontElem = FrontCell->Data;

<a name="kt6f-1644337085398"></a>free(FrontCell);    //释放被删除节点内存

<a name="lf8v-1644337114779"></a>return FrontElem;

<a name="sk0o-1644336830172"></a>}

<a name="r3nx-1677788272917"></a>**2.4 多项式的加减运算实现**

<a name="ktow-1644337425629"></a>**-采用不带头节点的单向链表，按照指数递减的顺序排列各项**

<a name="47ga-1644339395475"></a>struct PolyNode{

<a name="t4vx-1644339427692"></a>int coef; //系数

<a name="repw-1644339442188"></a>int expon; //指数

<a name="hzdx-1644339459388"></a>struct PolyNode \*link; //指向下一个节点的指针

<a name="l05a-1644339428315"></a>}；

<a name="hxcw-1644339488561"></a>typedef struct PolyNode \*Polynomial;

<a name="pr1x-1644339507655"></a>Polynomial P1, P2;

<a name="aunx-1644339525286"></a><a name="luyw-1644339550895"></a>**-算法思路：两个指针P1和P2分别指向这两个多项式的第一个节点，不断循环**

<a name="ayec-1644339604457"></a>**>P1->expon==P2->expon：**系数相加，若结果不为0，则作为结果多项式对象的系数。

<a name="ffaw-1644339716079"></a>同时，P1和P2都分别指向下一项；

<a name="zr5y-1644339609158"></a>**>P1->expon > P2->expon:**  将P1的当前项存入结果多项式，并使P1指向下一项；

<a name="aiek-1644339610695"></a>**>P1->expon < P2->expon:**  将P2的当前项存入结果多项式，并使P2指向下一项；

<a name="agze-1644412297229"></a>当某一个多项式处理完时，将另一个多项式的所有结点依次复制到结果多项式中去。

<a name="cmwe-1644412461754"></a><a name="gbua-1644412462094"></a>Polynomial polyAdd ( Polynomail P1，Polynomial P2){

<a name="nmhi-1644412545548"></a>Polynomial front, rear, temp;

<a name="u6hv-1644412572518"></a>int sum;

<a name="qswf-1644412575270"></a>rear = (Polynomial) malloc(sizeof( struct PolyNode));

<a name="udfg-1644412697167"></a>front  = rear;  //由front记录结果多项式链表头节点

<a name="wlxt-1644412702671"></a>while (P1 && P2)  // 当两个多项式都有非零项待处理时-循环P1,P2

<a name="eg9g-1644412786705"></a>switch( Compare(P1->expon,P2->expon)){

<a name="rwtl-1644412915795"></a>case 1:

<a name="xwdu-1644412921400"></a>Attach(P1-coef, P1->expon, &rear);

<a name="no4h-1644412986441"></a>P1=P1->link;

<a name="hy9d-1644413011120"></a>break;

<a name="5oe3-1644413019009"></a>case -1:

<a name="qolg-1644413026343"></a>Attach(P2->coef,P2->expon,&rear);

<a name="kjf0-1644413058770"></a>P2 = P2->link;

<a name="gzxk-1644413070216"></a>brak;

<a name="gtet-1644413074879"></a>case ():

<a name="igqg-1644413086978"></a>sum = P1->coef + P2->coef;

<a name="mzxp-1644413160049"></a>if( sum ) Attach(sum, P1->expon, &rear);

<a name="3fmd-1644413205122"></a>p1 = p1->link;

<a name="tdpg-1644413215343"></a>p2 = P2->lin;

<a name="ka4m-1644413224184"></a>break;

<a name="susb-1644412917024"></a>}

<a name="cyjf-1644413230793"></a>//将未处理完的另一个多项式的所有节点依次复制到结果多项式当中去

<a name="xcmz-1644413274481"></a>for(;P1; P1=P1->link) Attach(P1->coef,P1->expon,&rear);

<a name="vb2f-1644413347273"></a>for(;P2; P2=P2->link) Attach(P2->coef,P2->expon, &rear);

<a name="lxvn-1644413395542"></a>rear->link = null;

<a name="z6ak-1644413408984"></a>temp = front;

<a name="vh0s-1644413418214"></a>front =front->link;//令front 指向结果多项式第一个非零项

<a name="nog7-1644413458720"></a>free(temp);

<a name="hf7u-1644413465046"></a>return front;

<a name="wpdb-1644412546037"></a>}

<a name="bq37-1644489259408"></a><a name="o6vf-1644489259944"></a>void Attach( int c, int e, Polynomial \*pRear){

<a name="vaed-1644489338038"></a>Polynomial P;

<a name="5tbe-1644489351334"></a>P = (Polynomial) malloc( sizeof( struct PolyNode));

<a name="u9yh-1644489390939"></a>P->coef = c;

<a name="bd18-1644489424045"></a>P->expon = e;

<a name="gbjf-1644489432149"></a>p->link  = NULL;

<a name="ko6l-1644489443494"></a>(\*pRear)->link = P;

<a name="qrbw-1644489496548"></a>\*pRear = P;  //修改pRear值

<a name="u0ts-1644489339078"></a>}

<a name="zc0b-1644489859398"></a><a name="cnwo-1677788272918"></a>**3.1 什么是树**

<a name="ps6y-1644489957750"></a>事务存在**层次关系  分层次组织在管理上具有更高的效率**

<a name="8ejl-1644583255323"></a>**查找：**

<a name="7tkb-1644583260360"></a>**静态查找-记录固定，**无新增和删除，仅查找

<a name="tuwb-1644583567195"></a>顺序查找：1.哨兵-给边界值Tbl[0]一个特定的标识值（要查找值），for循环中可以少一个下标越界的判断。

<a name="jue6-1644583308262"></a>**动态查找-记录是动态变化的，**除了查找，还有可能发生插入和删除

<a name="vszi-1677788272919"></a>**3.1.2 二分查找法（Binary Search）**

<a name="yxgb-1644583872364"></a>前提条件：**有序的数组** （链表不行）

<a name="ph1p-1644588077356"></a><a name="kcxc-1677788272920"></a>**3.1.3二分查找实现**

<a name="8jxv-1644585404417"></a>int BinarySeach(List Tbl, ElementType K){

<a name="d787-1644585908986"></a>int left, right, mid, NoFound=-1;

<a name="fnte-1644585939690"></a><a name="zjdg-1644585942592"></a>left = 1;

<a name="bkos-1644585948018"></a>right = Tbl->Lenght;

<a name="h1w6-1644585961081"></a>while( left <= right){    //while 循环原来这么用的！简洁While(条件变量)

<a name="7isa-1644585977441"></a>mid = (left+right)/2;

<a name="mwkg-1644585994240"></a>if( K< Tbl-> Element[mid]) right = mid-1;//调整右边界

<a name="xqhf-1644586192252"></a>else if( K > Tbl-> Element[mid]) left = mid+1；//调整左边界

<a name="nbxx-1644586674362"></a>else return mid;  //查找成功，返回数据元素下标

<a name="z00k-1644585978857"></a>}

<a name="lppq-1644586709222"></a>return NotFound;  //查找不成功，返回-1；

<a name="ea0k-1644585909801"></a>}

<a name="9drt-1644588103453"></a><a name="vcio-1644588105020"></a>二分查找判定树 (比数组插入删除方便)

<a name="armw-1644588112596"></a>> **查找次数**刚好**为** 该结点所在的**层数**。

<a name="uoij-1644583855397"></a>>**查找次数不会超过**判定树的**深度**。

<a name="vswm-1644588786630"></a>> n个结点的判定树的深度为 **[log2n]+1**

<a name="cnel-1644589085153"></a>      8个结点 log2（2³）=3

<a name="rqny-1644589151572"></a>> 平均成功查找次数 ASL = (4\*4+4\*3+2\*2+1) = 3

<a name="jygu-1645443804901"></a><a name="9oui-1677788272921"></a>**3.1.4 树的定义**

<a name="8bmj-1645444077956"></a>**-树的基本术语**

<a name="pk2a-1645444083342"></a>**1. 结点的度：结点的子树(仅儿子结点)个树**

<a name="kooj-1645444153132"></a>**2. 树的度： 树中所有结点中最大的度数**

<a name="drni-1645444218360"></a>**3. 叶结点：度为0的结点**

<a name="uvld-1645444236707"></a>父结点、子结点、兄弟结点、路径和路径长度、祖先结点、子孙结点

<a name="9gsy-1645444277084"></a>**11. 结点的层次：根节点在1层**

<a name="7puj-1645444403712"></a>**12. 树的深度：最大层次**

<a name="xbdv-1677788272922"></a>**3.1.5 树的表示**

<a name="yhns-1645453382016"></a>**-数组X**

<a name="ud8i-1645453549209"></a>**-链表：使结点代码结构一致**

<a name="6qpk-1645453679575"></a>**1.儿子-兄弟表示法(左旋转45度)：**           

<a name="km7k-1645453717583"></a>Element

<a name="dsae-1645453711877"></a>FirstChild | NextSibling                        

<a name="t8n5-1645453807566"></a>**左旋转45度**     变二叉树

<a name="9vpy-1645453833089"></a>Element

<a name="oq08-1645453843045"></a>    Left | Right 

<a name="mfgy-1645453863839"></a>所以研究二叉树能解决大部分树问题

<a name="ign6-1647845341218"></a>**2.双亲表示法：孩子指向双亲（parent）**

<a name="ewbe-1699835372502"></a> 类似DB树结构部门，字段保存父结点

<a name="uhnr-1647845339973"></a><a name="ml79-1677788272923"></a>**3.2.1 二叉树的定义**

<a name="1baq-1645453994717"></a>**-特殊二叉树**

<a name="fl7g-1645454029441"></a>**1.斜二叉树    ---等价链表**

<a name="v6rh-1645454049742"></a>**2.完美二叉树 / 满二叉树      --叶子节点满**

<a name="od9j-1645454078512"></a>**3.完全二叉树   --结点与满二叉树编号位置相同。**

<a name="l8wx-1699835413536"></a>（允许叶子结点缺少-允许从右开始顺序减少叶子结点，但是编号和位置要一致）

<a name="3clv-1645454118085"></a>**-几个重要性质**

<a name="3obh-1645454309964"></a>**1.第i层最大结点数： 2的 i-1 次方**

<a name="qpoe-1645454336724"></a>**2.深度为K的二叉树最大结点总数：  2的K次方减1**

<a name="cp2x-1645454444904"></a>**3.n0 = n2 +1  n2是度为2的非叶结点个数，n0表示度为0（即叶子结点）的个数   ps:度-子树个数**

<a name="4v0u-1645455011406"></a>**-二叉树的抽象数据类型定义**

<a name="tagu-1645455020466"></a>**1.类型名称： 二叉树**

<a name="kanq-1645455032298"></a>**2.数据对象集： 一个又穷的结点集合**

<a name="qqbq-1645455052796"></a>若不为空，则由根结点和其左、右二叉子树组成。

<a name="hz54-1645455088206"></a>**3.操作集：**

<a name="o74r-1699835495494"></a>**.Boolean IsEmpty(BinTree BT)** 

<a name="peq4-1645455133062"></a>**.void Traversal(BinTee BT)  ; 遍历，按某个顺序访问每个结点** 

<a name="xorm-1645455229565"></a>**. BinTree CreateBinTree(): 创建一个二叉树**

<a name="nqbl-1645455308856"></a>**4.树的遍历通常和算法相关**

<a name="lub5-1699835595523"></a>**.先序/先根遍历   根、左子树、右子树**

<a name="nplc-1699835599754"></a>**.中序 左 根 右**

<a name="rpml-1699835604145"></a>**.后序    左 右  根**

<a name="m0un-1699835610234"></a>**. 层次遍历  从上到下，从左到右**

<a name="twfr-1645455323317"></a>void PreOrderTraversal(BinTree BT)** 

<a name="adgy-1645455354543"></a>void InOrderTraversal(BinTree BT) 

<a name="wmw3-1645455426300"></a>void PostOrderTraversal(BinTree BT) 

<a name="anlv-1645455427933"></a>void LevelOrderTraversal(BinTree BT)

<a name="2alp-1677788272924"></a>**3.2.2 二叉树的存储结构**

<a name="yxwc-1645456901635"></a>**-顺序存储结构**

<a name="beah-1645456933574"></a>**1.完全二叉树：**

<a name="ddjk-1699835659834"></a> 按从上至下，从左到右顺序存储**n**个结点的完全二叉树的**结点父子关系**：结点值 、 结点序号

<a name="btus-1645457032873"></a>非根结点（序号i>1）的父结点的序号是 i/2

<a name="av3i-1645457130421"></a>结点i 的左孩子结点序号是 2i；（且2i>=n,否则没有左孩子 ）

<a name="ncfc-1645457344820"></a>结点i 的右孩子结点序号是2i+1 ; （且2i + 1>=n,否则没有右孩子 ）

<a name="atjn-1645457415013"></a>**2.一般二叉树** 

<a name="7ybq-1699835674362"></a>也可以采用这种结构，但是会造成空间浪费 (空结点用null补充）   

<a name="gdho-1645457518453"></a><a name="z9rr-1645457520347"></a>**- 链表存储**

<a name="eojv-1645457748883"></a>typedef struct TreeNode \*BinTree;

<a name="lzwu-1645457798857"></a>typedef BinTree Position;

<a name="a2it-1645457602951"></a>struct TreeNode{

<a name="j5yt-1645457620412"></a>ElementType Data;

<a name="ozua-1645457729203"></a>BinTree Left;

<a name="b59j-1645457736443"></a>BinTee Right;

<a name="bhuj-1645457620987"></a>}

<a name="8prz-1677788272925"></a>**3.3.1 二叉树的遍历(递归-堆栈)**

<a name="sqd4-1645542047590"></a>**-先序遍历**

<a name="uwoq-1645542105742"></a>void PreOrderTraversal(BinTree BT){

<a name="6sbu-1645542123420"></a>if（BT）{

<a name="x9uq-1645542134412"></a>  printf( "%d" , BT->Data);

<a name="84oo-1645542165134"></a> PreOrderTraversal（BT->Left）；

<a name="jefw-1645542222933"></a>PreOrderTraversal（BT->Right）；

<a name="kq9c-1645542135036"></a>}

<a name="i6q6-1645542124341"></a>}

<a name="zbbh-1645542351803"></a>**-中序遍历**

<a name="i3ln-1645542364044"></a>void InOrderTraversal(BinTree BT) {

<a name="ste4-1645542369260"></a>if（BT）{  //结点

<a name="fhtg-1645542378198"></a> InOrderTraversal（BT->Left）；

<a name="aric-1645542393066"></a>printf( "%d" , BT->Data);

<a name="x8lo-1645542378200"></a>InOrderTraversal（BT->Right）；

<a name="lobd-1645542378202"></a>}

<a name="i4b3-1645542370212"></a>}

<a name="wcx7-1645620627575"></a>**-后续序遍历**

<a name="nk1g-1645620637646"></a>**    void  PostOrderTraversal(BinTree BT){

<a name="tmki-1645620837750"></a>if (BT){       // 1次

<a name="ctlg-1645620846843"></a> PostOrderTraversal(BT->Left);  //2次

<a name="5jkd-1645620889269"></a> PostOrderTraversal(BT->Rightt);   // 3次 遍历过程中经过结点的路线一样，只是访问（print）各结点的时机不同。共3次碰到的机会，1（中），左（2）右（3）

<a name="t3gv-1645621093907"></a>printf( "%d" , BT->Data);     

<a name="wvjj-1645620847427"></a>}

<a name="ebe1-1645620838499"></a>}

<a name="pstm-1645621096502"></a>先序：A BDFE CGHI

<a name="jfjv-1645621218756"></a>中序：DBEF A GHCI

<a name="juyv-1645621381674"></a>后序号：DEFB HGIC A     

<a name="p5gh-1677788272926"></a>**3.3.2 中序非递归遍历**

<a name="mvcm-1645621765999"></a>**-中序遍历的非递归遍历算法 （牛逼）**

<a name="ylqq-1645630230158"></a>>当遇到一个结点，就把它压入栈，并去遍历它的左子树

<a name="8azo-1645630270068"></a>>当左子树遍历结束后，从栈顶弹出这个结点并访问它；

<a name="wkbr-1645630320037"></a>>然后按其右指针再去中序遍历该结点的右子树。

<a name="z811-1645630356897"></a>void InorderTraversal ( BinTree BT ){

<a name="hfne-1645630381171"></a>BinTree T = BT;

<a name="lubv-1645630395674"></a>Stack S = CreateStack ( MaxSize); //创建并如石化堆栈S

<a name="lodu-1645630441139"></a>while( T || !IsEmpty(S) ){

<a name="owtr-1645630471356"></a>while ( T ) { //一直向左并将沿途结点压入堆栈

<a name="n9mv-1645631841583"></a>// 先序遍历的话 printf ( " %5d", T->Data ); 放这里

<a name="etb6-1645630588015"></a>Push ( S, T );

<a name="82pk-1645630723956"></a>T = T -> Left ;

<a name="zlek-1645630498116"></a>}

<a name="sqxg-1645630744747"></a>if ( !IsEmpty( S )) {

<a name="yopv-1645630817423"></a>T = Pop ( S )； //结点弹出堆栈

<a name="mqxy-1645630923204"></a>printf ( " %5d", T->Data );  // （访问）打印结点

<a name="syaf-1645630968496"></a>T  = T -> Right ; //转向右子树

<a name="dhky-1645630818027"></a>}

<a name="o3sk-1645630472067"></a>}

<a name="nikg-1645630381644"></a>}

<a name="ivxu-1645620638320"></a>**思考：后续遍历非递归算法？**

<a name="fuec-1645620638518"></a><a name="y0gg-1677788272928"></a>**3.3.3 层序遍历**

<a name="yiya-1645710174947"></a>**-二叉树遍历的核心问题： 二维结构的线性化**

<a name="16g4-1645710208003"></a>>从结点访问其左、右儿子结点

<a name="xolb-1645710314364"></a>>访问左儿子后，右儿子怎么办

<a name="o3n0-1645710381616"></a>      >> 需要一个存储结构保存暂时不访问的结点

<a name="rcfi-1645710407381"></a>      >> 存储结构： 堆栈、队列

<a name="dp48-1645710470408"></a>**-队列实现：**

<a name="oojb-1699835823870"></a>遍历从根节点开始，首先将根节点入队，然后开始执行循环：结点出队，访问该结点、其左右儿子入队

<a name="6qve-1645711079896"></a>层序基本过程：

<a name="2bjz-1645711109676"></a>先根结点入队，然后：

<a name="wjf0-1645711118001"></a>**1.从队列取出一个元素**

<a name="iyau-1645711129851"></a>**2.访问该元素所指结点**

<a name="wjzk-1645711151463"></a>**3.若改元素所指结点的左、右孩子结点非空，**

<a name="k0fg-1645711191275"></a>则将其左右孩子的指针顺序入队。

<a name="2pue-1645711665976"></a><a name="ep6g-1645711225719"></a>void LevelOrderTraversal ( BinTree BT){  //牛逼就完事了

<a name="ed2i-1645711255071"></a>Queue Q;BinTree T;

<a name="jgwa-1645711284942"></a>if ( !BT ) return ; // 若是空树则直接返回

<a name="vml2-1645711321856"></a>Q = CreateQueue ( MaxSize ) ;  // 创建并初始化队列

<a name="onoo-1645711363427"></a>AddQ ( Q, BT );

<a name="oprc-1645711384793"></a>while ( !IsEmptyQ ( Q )) {

<a name="y23c-1645711467421"></a>T = DeleteQ ( Q );

<a name="eqpx-1645711531587"></a>printf ( "%d\n", T->Data); //访问取出队列的结点

<a name="yblj-1645711569050"></a>if（ T-> Left ）AddQ ( Q, T->Left );

<a name="kir7-1645711600998"></a>if ( T- > Right ) AddQ ( Q, T->Right);

<a name="hipj-1645711468551"></a>}

<a name="owzy-1645711255430"></a>}

<a name="zfv3-1645620638710"></a><a name="7j0x-1677788272929"></a>**3.3.4 遍历应用的列子**

<a name="cxle-1645620638879"></a>**-输出二叉树中的叶子结点**

<a name="dxb2-1645711845776"></a>void PreOrderTraversal(BinTree BT){

<a name="7vos-1645711895455"></a>if（BT）{

<a name="8iuk-1645711900308"></a>if ( ! BT->Left && ! BT-> Right )

<a name="vrta-1645711895459"></a>  printf( "%d" , BT->Data);

<a name="acfv-1645711895462"></a> PreOrderTraversal（BT->Left）；

<a name="vzeg-1645711895465"></a>PreOrderTraversal（BT->Right）；

<a name="jrdi-1645711895469"></a>}

<a name="f4m3-1645711895474"></a>}

<a name="oasx-1645711968602"></a>**- 求二叉树的高度**   

<a name="z2d6-1645712054475"></a>注：Height = Max (H左，H右) +1

<a name="ffys-1645712345806"></a>  void  PostOrderTraversal(BinTree BT){

<a name="kqkv-1645712346657"></a>if (BT){      

<a name="jxae-1645712346661"></a> HL = PostOrderTraversal(BT->Left);  // 求左子树深度

<a name="cqaj-1645712346664"></a> HR =  PostOrderTraversal(BT->Left);   //求右子树深度

<a name="sby2-1645712346677"></a>MaxH = ( HL > HR ) ? HL : HR;   // 取左右子数较大的深度

<a name="ytxp-1645712494155"></a>return ( MaxH +1);  

<a name="hv8e-1645712346687"></a>}

<a name="4ypu-1645712511117"></a>else return 0; //空树深度为0

<a name="m21n-1645712346695"></a>}

<a name="xro3-1645712589755"></a><a name="jjrf-1645712590444"></a>**-二元运算表达式数及其遍历**

<a name="xx0m-1645712667342"></a>先序：++a\*bc\*+\*defg正确

<a name="7tve-1645712704997"></a>中序：a+b\*c+d\*e+f\*g      中缀表达式会受到运算符优先级的影响，解决：左子树遍历时加左括号，遍历完加右括号

<a name="ow2p-1645712707808"></a>后序：abc\*+de\*f+g\*+      正确

<a name="7rgc-1645713282286"></a><a name="rqfj-1645713283207"></a>**-由两种遍历序列确定二叉树**

<a name="ryzk-1645713314351"></a>必须要有中序遍历才行！  先序根在第一，后序在末尾，要有中序才能知道 左右子树的划分。

<a name="imes-1645620639123"></a>**先序和中序遍历确定一颗二叉树**

<a name="orul-1645713497821"></a>分析：

<a name="ze91-1645713502943"></a>根据**先序**遍历序列第一个节点确定**根节点**；

<a name="mxjm-1645713525492"></a>根据根节点在**中序**遍历中分割出**左右两个子序列**

<a name="c5zy-1645713551239"></a>对**左子树 和右子树分别 递归使用**相同的方法 继续分解。

<a name="zcym-1645713488990"></a><a name="o2qw-1677788272930"></a>**4.1.1 二叉搜索树及查找**

<a name="vx6c-1646574667847"></a>左子结点比根节点小，右子节点比根大

<a name="aum2-1646574743624"></a>同时子树也是左小右大的二叉树

<a name="yefy-1646574780329"></a>**-二叉搜索树的查找操作Find**

<a name="a74g-1646574809858"></a>Position Find ( ElementType X, BinTree BST){

<a name="x0ox-1646574843446"></a>if (!BTS) return NULL: //查找失败

<a name="zdup-1646574864723"></a>if （ X> BST -> Data）

<a name="hlka-1646574882071"></a>return Find ( X, BST -> Right ); //在右子树中继续查找

<a name="xd06-1646574917040"></a>Else if ( x < BST -> Data)

<a name="ij5r-1646574844737"></a>return Find (X , BST -> Left) ；//尾递归- 程序return的时候进行递归调用

<a name="b8sf-1646574974033"></a>else

<a name="h9ai-1646574982793"></a>    return BST; //查找成功，返回找到结点的地址

<a name="v92s-1646574843761"></a>}

<a name="d9oj-1646575119810"></a>**-尾递归都可以用循环实现**

<a name="ixuw-1645620640796"></a>Position IterFind ( ElementType x, BinTree BST){

<a name="hu2p-1646575207150"></a>while( BST ) {

<a name="m11m-1646575217489"></a>if ( X > BST -> Data)

<a name="gypq-1646575235322"></a>BST = BST -> Right;

<a name="llcj-1646575251090"></a>else if ( X < BST-> Data)

<a name="raer-1646575278747"></a>BST = BST -> Left; //**查找效取决树的高度**

<a name="qmim-1646575295866"></a>else 

<a name="mve8-1646575298410"></a>return BST:

<a name="julo-1646575314419"></a>)

<a name="agbp-1646575317675"></a>return Null; //查找失败

<a name="mgsv-1646575207505"></a>}

<a name="m4z6-1646575431174"></a>**-查找最大和最小元素**

<a name="hnao-1646575443136"></a>最大：最右分支的端结点上

<a name="i8eq-1646575473024"></a>最小：最左的端结点上

<a name="tgks-1646575485377"></a>Position FindMin ( BinTree BST ){

<a name="soat-1646575527421"></a>if ( !BST) return NULL; //空的二叉搜索树

<a name="xkh9-1646575557187"></a>else if（ ！BST -> Left）

<a name="agku-1646575573616"></a>return BST: //找到最左叶子系欸但并返回

<a name="7j0s-1646575619264"></a>else 

<a name="qsmc-1646575622920"></a>return FindMin (BST->Left); //沿左子树接续查找

<a name="kylz-1646575527787"></a>}

<a name="6sbw-1646575651963"></a>Postition FindMax ( BinTree BST){

<a name="zkro-1646575672345"></a> if (BST) 

<a name="fj3b-1646575683296"></a>while ( BST -> Right) 

<a name="1qno-1646575700873"></a>BST = BST -> Right; //沿右分支继续查找，直到最右叶子节点

<a name="1ggj-1646575739614"></a>return BST；

<a name="40i6-1646575673336"></a>}

<a name="uzot-1645542116069"></a><a name="lehm-1677788272931"></a>**4.1.2 二叉搜索树的插入**

<a name="ejww-1646577628505"></a>找到应该插入的位置，和find 差不多

<a name="1lcd-1646575893725"></a>BinTree Insert ( ElementType X, BinTree BST){

<a name="swyf-1646576034147"></a>if (!BTS)

<a name="q2rj-1646576053029"></a>//若原树为空，生成并返回一个结点的二叉树

<a name="nwnp-1646576090361"></a>BST = malloc (sizeOf (struct TreeNode));

<a name="ifda-1646576114594"></a>BST->Data = x;

<a name="xt96-1646576123634"></a>BST -> Left = BST -> Right = Null;

<a name="rsol-1646576168949"></a>else  // 开始查找要插入的位置

<a name="ykff-1646576172497"></a>if （ X< BST -> Data）

<a name="o7lo-1646576034150"></a>BST->Left = Insert ( X，BST-> Left); //递归插入左子树

<a name="nvzd-1646576034152"></a>Else if ( x > BST -> Data)

<a name="c2wb-1646576034153"></a>BST->Ritht = Insert ( X，BST-> Right); //递归插入右子树

<a name="jnio-1646576034156"></a>   return BST; 

<a name="399q-1646576034158"></a>}

<a name="2k4k-1646576376337"></a><a name="e7rv-1677788272932"></a>**4.1.3 二叉搜索树的删除**

<a name="krvg-1646577074336"></a>分三种情况：

<a name="0077-1646577661966"></a>**-删除的是叶子结点，**

<a name="jnrr-1699835949713"></a>**直接删除，并再修改其父结点指针 --置为NULL;**

<a name="qatj-1646577728059"></a>**-只有一个孩子结点：**

<a name="vvtl-1699835950728"></a> **将父结点的指针指向要删除的孩子结点**

<a name="ka9m-1646577770541"></a>**-有左右两颗子树：**

<a name="hp5p-1699835951586"></a>**用另一结点替代被删除的结点，右子树最小元素，或者左子树最大元素**

<a name="tq2j-1646577074535"></a>BinTree Delete ( ElementType X, BinTree BST){

<a name="oesp-1646578030490"></a>Positon Tmp;

<a name="67y0-1646577075050"></a>if (!BTS)  printf( “要删除的元素未找到 ”)；

<a name="u61k-1646578067237"></a>else if （ X< BST -> Data）

<a name="z0qw-1646578093561"></a>BST->Left = Delete ( X，BST-> Left); //递归删除左子树

<a name="awof-1646578140047"></a>Else if ( x > BST -> Data)

<a name="4aqb-1646577075064"></a>BST->Ritht = Delete ( X，BST-> Right); //递归删除右子树

<a name="whbt-1646578162088"></a>else  // 找到要删除的结点

<a name="bxe0-1646577075060"></a>if （ BST->Left  && BST->Right ）//被删除的结点有左右两个子结点

<a name="nvtk-1646578221346"></a>Tmp = FindMin ( BST->Right )

<a name="fkai-1646578264339"></a>//在右子树中找最小的元素填充删除结点

<a name="3ocv-1646578292557"></a>BST ->Data = Tmp ->Data;

<a name="ut2w-1646578316840"></a>BST -> Right = Delete ( BST -> Data, BST -> Right);

<a name="i93d-1646578381390"></a>//在删除结点的右子树中删除最小元素

<a name="q8xn-1646577075051"></a>else  // 被删除结点有一个或无子系结点

<a name="93oe-1646578471010"></a>Tmp = BST;

<a name="hux7-1646578471011"></a>if ( BST -> Left ) //有右孩子 或无子结点

<a name="sfjo-1646578471013"></a>BST = BST -> Right;

<a name="xeos-1646578471015"></a>else if ( BST -> Right ) //有左孩子 或无子结点

<a name="0h3s-1646578648703"></a>BST = BST -> left;

<a name="bbla-1646577075058"></a>free ( Tmp );

<a name="9cgl-1646577075066"></a>   return BST; 

<a name="ueys-1646577075067"></a>}

<a name="vszn-1677788272933"></a>**4.2.1 平衡二叉树**

<a name="p98v-1646580853913"></a>**-什么是平衡二叉树**

<a name="ex8z-1646580859710"></a>**1.深度和平均查找长度ASL 最小的二叉树结构**

<a name="vgir-1646581014297"></a>**2.平衡因子  ：左右子树高度差 BF(T) = H左 - H 右**

<a name="rmzf-1646581088479"></a>**3.平衡二叉树： （AVL树）**

<a name="jp4t-1646581113063"></a>空树，或者 任一结点**左、右子树**高度差绝对值不超过1 ，即| BF(T)| <=1;

<a name="pxyy-1646581252367"></a>平衡二叉树的高度能达到log2n 吗？满二叉树高度 log2n

<a name="k4kw-1646581324581"></a>数学推断--- AVL的最大高度是log2n

<a name="iezk-1646581177437"></a><a name="utk5-1677788272934"></a>**4.2.2 平衡二叉树的调整 （保证每个结点平衡因子| BF(T)|<=1）**

<a name="kbpt-1646582987324"></a>四种情况 **破坏者与被破坏者的位置关系** ，下面以插入破坏为例

<a name="kuqb-1646581501829"></a>**-右单旋：**

<a name="gyez-1699836029186"></a>**麻烦结点**在**被破坏者**右子树的右边，因而叫RR插入，需要RR旋转（右单旋）

<a name="wa6j-1646582121494"></a>**-左单旋：**

<a name="jhby-1699836030051"></a>麻烦结点在左子树下面，因而叫LL插入。

<a name="jmg3-1646582185738"></a>**-LR旋转：**

<a name="q4ek-1699836030869"></a> 麻烦结点在左子树的右子树下面，因而叫LR旋转

<a name="dd9e-1646581849728"></a>**-RL旋转：**

<a name="e67p-1699836031590"></a>麻烦结点在右子树的左子树下面，叫RL旋转

<a name="njsw-1646582653739"></a><a name="fkbx-1677788272935"></a>**5.1.1 什么是堆**

<a name="8teh-1646654863957"></a>**-优先队列（Priotiry Queue）**

<a name="fixt-1699836073654"></a>:特殊的队列，取出元素的顺序是依照元素的**优先权（关键字）**大小，而不是元素进入队列的先后顺序

<a name="kvg3-1646654971440"></a>**-实现：**

<a name="eckj-1646654974527"></a>**1.数组： 插入-元素总是插入尾部    删除-查找最大（或最小）关键字，从数组中删去要移动的元素**

<a name="upag-1646655035201"></a>**2.链表： 插入-元素总是插入链表的头部  删除-查找最大（或最小）关键字，删去结点**

<a name="ivi1-1646582654691"></a>**3.有序数组： 插入-找到合适的位置移动元素并插入    删除-删去最后一个元素**

<a name="lwz7-1646655242369"></a>**4.有序链表：插入-找到合适的位置插入元素  删除-删除首元素或最后元素**

<a name="hnp6-1646655294856"></a><a name="rnqq-1646655322095"></a>二叉树存储结构（优先队列的**完全二叉树**表示）

<a name="b3fy-1646655452745"></a>**-堆的两个特性：**

<a name="n5ng-1646655472739"></a>**1.结构性-用数组表示的完全二叉树**

<a name="udr3-1646655488799"></a>**2.有序性：任一节点的关键字是其子树所有结点的最大值（或最小值）**

<a name="lnqt-1646655535218"></a>**最大堆，也成大顶堆**：最大值

<a name="y38l-1646655553164"></a>**最小堆 ，也称小顶堆**：最小值

<a name="7nbc-1646655339057"></a>注意：**从根节点到任一结点路径上结点序列的有序性！**

<a name="2gjv-1646655778644"></a><a name="eghz-1677788272936"></a>**5.1.2堆的插入**

<a name="k7eg-1646655793805"></a>**-最大堆的创建**

<a name="u2sc-1646655799145"></a>typedef struct HeapStruct \*MaxHeap;

<a name="4uvn-1646655819683"></a>struct HeapStruct {

<a name="xhsn-1646655831391"></a>ElementType \*Elements; //存储堆元素的数组    --看完全二叉树的数组实现定义

<a name="4gyn-1646655860681"></a>int Size; //堆的当前元素个数

<a name="vnun-1646655877366"></a>int Capacity; //堆的最大容量

<a name="qsdy-1646655828550"></a>}

<a name="gfnz-1646655928633"></a><a name="rbft-1646655928809"></a>MaxHeap Create( int MaxSize){

<a name="hmyt-1646655947381"></a> MaxHeap H = malloc ( sizeof ( struct HeapStruct ));

<a name="tcm7-1646655980846"></a>H->Elements = malloc ( (MaxSize+1) \* sizeOf (ElmentType ));

<a name="ypyu-1646656043214"></a>H->Size  = 0;

<a name="yuls-1646656054889"></a>H-> Capacity = MaxSize;

<a name="di7g-1646656067569"></a>H-> Elements[0] = MaxData;

<a name="0ljm-1646655947559"></a>//定义哨兵为大于堆中所有可能元素的值，便于以后更快操作

<a name="ptlr-1646656132635"></a>return H;

<a name="kowo-1646655947715"></a>}

<a name="vzbs-1646655909501"></a>**-将新增结点插入到其父节点到根节点的有序序列中**

<a name="k11p-1646655909724"></a>void Insert (MaxHeap H, ElementType item) {

<a name="pcfx-1646656331922"></a>int i;

<a name="wc8k-1646656337840"></a>if ( IsFull (H )) {

<a name="7e2a-1646656354246"></a>printf( "最大堆已满 ")

<a name="8g61-1646656354720"></a>}

<a name="gjd8-1646656375818"></a>i = ++H-> Size; // i指向插入后堆中的最后一个元素的位置

<a name="vivd-1646656414548"></a>for （ ： H-> Elements[ i/2 ] < item ; i/=2）    // i=i/2 父节点    当前结点比父节点大  ，到最大根节点时（循环需要判断i>1才不会跳出树），哨兵判断

<a name="ev8y-1646656514792"></a>H-> Elements[i] = H->Elements [ i/ 2 ]; //向下过滤结点

<a name="adcc-1646656554531"></a>H-> Elements [i] = item; //将item 插入

<a name="nbib-1646656332346"></a>}

<a name="nc2h-1646656963696"></a><a name="5p6t-1677788272937"></a>**5.1.3 堆的删除**

<a name="6odd-1646657014073"></a>ElementType DeleteMax( MaxHeap H){

<a name="6ibs-1646657311931"></a>int Parent, Child;

<a name="pvxd-1646657354619"></a>ElementType MaxItem, temp;

<a name="bkiw-1646657365313"></a>if ( IsEmpty(H)){

<a name="ltjm-1646657378868"></a>printf ("最大堆已为空")；

<a name="6ihx-1646657402377"></a>return;

<a name="7r1q-1646657379433"></a>}

<a name="syrp-1646657411399"></a>MaxItem = H -> Elements[1]; //取出根节点最大值

<a name="cxvf-1646657494448"></a>// 用最大堆中最后一个元素从根节点开始向上过滤下层结点

<a name="pk1r-1646657555739"></a>temp = H -> Elements[ H-> Size -- ];

<a name="1jop-1646657577590"></a>for ( Parent =1; Parents\*2 < = H- > Size; Parent = Child) {   //Parents\*2 < = H- > Size 判断是否有左儿子  Child左 = 2i, child右 = 2i+1

<a name="tnhg-1646657620256"></a>Child = Parent \*2;

<a name="fc5u-1646657634646"></a>if ( (Child != H->Size ) && ( H-> Elements[Child] < H -> Element [Child +1 ]) )

<a name="ktnk-1646657747842"></a>child ++; // Child 指向左右子结点的较大者

<a name="qq0t-1646657791629"></a>if ( temp >= H-> Elements[ Child] ) break;   //已是最大

<a name="ntst-1646657831391"></a>else  //移动temp元素到下一层

<a name="3ytd-1646657835991"></a>H->Elements[ Parent ] = H->Element [Child];

<a name="bqyd-1646657621113"></a>}

<a name="lvsu-1646657868913"></a>H->Element[ Parent ] = temp;

<a name="r0n9-1646657883972"></a>return MaxItem;

<a name="3esv-1646657312385"></a>}

<a name="zmxw-1646658169624"></a><a name="1gp9-1677788272938"></a>**5.1.4 堆的建立**

<a name="ccis-1646658181713"></a>**-堆排序**

<a name="fymy-1646658189054"></a>建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中 

<a name="yvhd-1646658228076"></a>方法1- 将N个元素一个一个相继插入到一个初始为空的堆中区，其时间代价最大为O( N logN )

<a name="9rlr-1646658416097"></a>方法2：在线性时间复杂度下建立最大堆。

<a name="yxz5-1646658438789"></a>1）将N个元素按输入顺序存入，先满足**完全二叉树的结构特性**

<a name="libe-1646658478352"></a>2）调整各节点位置，以满足最大堆的**有序特性**。

<a name="e4lp-1646658701200"></a><a name="a2ww-1646658702339"></a>每个子树从底开始调成最大堆，最后一步是左右子树为堆，再最后调整一次为最大堆。

<a name="bbd1-1646659064130"></a><a name="upwp-1677788272939"></a>**5.2.1 哈夫曼树与哈夫曼编码**  

<a name="chll-1646659093007"></a>**-压缩字节！！根据出现频率设置权重，优化查找。**

<a name="lbwn-1646659290159"></a>定义：

<a name="gvi6-1646659294157"></a>带权路径长度（WPL）: 设二叉树有n个叶子结点（权值）：WPL = i\*权 + ...

<a name="cbrh-1646659399289"></a>**-最优二叉树/哈夫曼树： WPL 最小的二叉树**

<a name="784n-1646659617901"></a><a name="oaxy-1677788272940"></a>**5.2.2 哈夫曼树的构造**

<a name="ofhq-1646659647574"></a>非常简单，每次把权值最小的两颗二叉树合并（父节点等于和），再把权值小的两颗树（包括了刚刚的和）合并，循环就得到叶子结点为权重

<a name="y6ox-1646660738330"></a><a name="tcvt-1646660738563"></a>**-如何选取两个最小的--利用最小堆**

<a name="ipcn-1646660157602"></a>typedet struct TreeNode \*HuffmanTree;

<a name="zxmk-1646660184105"></a>struct TreeNode{

<a name="hvc0-1646660191317"></a>int Weight;

<a name="33ct-1646660198593"></a>HuffmanTree Left, Right;

<a name="i3bq-1646660192139"></a>}

<a name="uw15-1646660216569"></a>HuffmanTree Huffman ( MinHeap H){

<a name="qq0y-1646660274543"></a>// 假设 H->Size 个权值已经存在 H-> Elements[] -> Weight 里

<a name="odqw-1646660238218"></a>int i ; HuffmanTree T;

<a name="86lt-1646660253354"></a>BuildMinHeap(H); // 将 H-> Elements[] 按权值调整为最小堆

<a name="kzfw-1646660357004"></a>for ( i = 1; i < H -> Size; i++) {  //做H->Size-1 次合并

<a name="wskd-1646660386623"></a>T = malloc ( sizeof ( struct TreeNode)); //建立新结点

<a name="6g5l-1646660480146"></a>T-> Left = DeleteMin (H);

<a name="or5o-1646660498583"></a>//从最小堆中删除一个结点，作为新T的左子结点

<a name="sskp-1646660550172"></a>T-> Right = DeleteMin (H);

<a name="0f9r-1646660574726"></a>//从最小堆中删除一个结点，作为新T的右子结点

<a name="6tbx-1646660589928"></a>T->Weight = T -> Left -> Weight + T->Right -> Weight;

<a name="zkz6-1646660641086"></a>//计算新权值

<a name="aric-1646660625259"></a>insert ( H, T) ;  //将新T 插入最小堆

<a name="b5kp-1646660387285"></a>}

<a name="hxnm-1646660679339"></a>T = DeleteMin (H);

<a name="rxhv-1646660694708"></a>return T;

<a name="izde-1646660238804"></a>}

<a name="k55i-1646660718393"></a>上面算法时间复杂度为：O(N log N)

<a name="kwx2-1646660786575"></a>**-哈夫曼树的特点：**

<a name="vney-1646660929619"></a>**1.没有度为1的结点；**

<a name="rmhw-1646660939676"></a>**2.n个叶子结点的哈夫曼树共有2n-1个结点；**

<a name="yg50-1646661094503"></a>**3.哈夫曼树的任意非叶子结点的左右子树交换后仍是哈夫曼树；**

<a name="3vek-1646661132877"></a>**4.同一组权值，可存在不同构的两颗哈夫曼树。WPL仍一样。**

<a name="ysvy-1677788272941"></a><a name="wquu-1677788272942"></a>**5.2.3 哈夫曼编码(存储空间最小/代价最小wpl)**

<a name="xjho-1646665028134"></a>给定一段字符串，如何对字符进行编码，使得该字符串的**存储空间最小/代价最小wpl  ---**压缩文件，且解码速度快

<a name="2zjt-1646665112607"></a><a name="7cgy-1646665234136"></a>使其无二义性/ 某字符编码不为另一字符编码的前缀-字符存在叶子结点

<a name="ftrr-1646665405252"></a>构造哈夫曼树 wpl最小

<a name="7byt-1646748564704"></a><a name="yfwk-1677788272943"></a>**5.3.1 集合的表示与查找**

<a name="amg2-1648133035306"></a>**-集合运算：交，并，补，差，判定一个元素是否属于某一个集合**

<a name="opn5-1648133351996"></a>**-并查集：集合并，查某元素属于什么集合 （A连接B,B连接C, A一定与C连接）传递性**

<a name="fh2i-1648133386745"></a>**-并查集合的存储如何实现**

<a name="4e2s-1648133451444"></a>**1.可以用树结构表示集合，每个结点代表一个集合元素**

<a name="blca-1648133486851"></a>**2.双亲表示法：子结点指向父结点（有点像DB部门设计）**

<a name="5rpq-1648133577547"></a>**-存储形式　：**

<a name="errq-1648133592538"></a>**1.链表**

<a name="o5ma-1648133596331"></a>**2.数组：**

<a name="0jcm-1699836443390"></a>根节点，parent = -1

<a name="mfic-1648134416151"></a>typedef struct{

<a name="afok-1648134426649"></a>ElementType Data;

<a name="5edi-1648134434001"></a>int Parent;

<a name="ssum-1648134427081"></a>}SetType;

<a name="sfev-1648134440603"></a>int Find( SetType S[] , ElementType X){

<a name="34hu-1648134482011"></a>int i;

<a name="tvpd-1648134492112"></a>for ( i=0; i<MaxSize && S[i].Data !=X; i++);

<a name="kb2r-1648134550536"></a>if ( i>= MaxSize) return -1; //未找到x, 返回-1；

<a name="lag7-1648134584686"></a>for ( ; S[i].Parent>=0; i = S[i].Parent);  //牛逼，一层一层找上去

<a name="lfld-1648134623135"></a>return i;  //找到X所属集合，返回树根结点在数组S中的下标

<a name="byvu-1648134482562"></a>}

<a name="lpay-1677788272944"></a>**5.3.2 集合的并运算**

<a name="9rwh-1648135126096"></a>分别找到 X1 和 X2 两个元素所在结合树的根结点；

<a name="saba-1648135170630"></a>如果他们不同根，则将其中一个根节点的父结点指针设置成另一个根节点的数组下标。

<a name="5xnf-1648135421761"></a>void Union( SetType S[], ElementType X1, ElementType X2){

<a name="zij4-1648135461709"></a>int Root, Root2;

<a name="w1wn-1648135470536"></a>Root1 = Find(S, X1);

<a name="3cgm-1648135481080"></a>Root = Find (S, X2);

<a name="5nod-1648135491616"></a>if ( Root1 != Root2 ) S[Root2].parent = Root1; 

<a name="pqjq-1648135463832"></a>}

<a name="jr5g-1648135543066"></a>扩展，高度小的连接到高度高的(查找效率)，避免增加树的高度   root.parent

<a name="en6i-1678812601685"></a><a name="jr61-1678812601851"></a>**6.2.1 DFS （递归or栈）**

<a name="vtgn-1678568019491"></a>深度优先搜索算法（Depth First Search，简称DFS）是一种用于**遍历或搜索树（先序遍历）或图**的算法。它的基本思想是从一个起始节点开始，**沿着当前分支尽可能深入，直到不能继续为止，然后回溯到上一个节点**，继续选择另一个分支进行搜索，直到访问完所有可达节点¹²³。DFS可以用递归或栈来实现。

//回溯算法 DFS 生成n对括号的组合

public static void backtrack(List<String> res, String s, int left, int right, int n){

`    `if(s.length() == 2 \* n){

`        `res.add(s);

`        `return;

`    `}

`    `if(left < n) {

`        `backtrack(res, s+"(", left+1, right, n); //3 (((  2 ((  (

`    `}

`    `if(right < left) {

`        `backtrack(res, s+")", left, right+1, n);// 3 )))  2  )  ))

`    `}

<a name="zcsx-1678568073160"></a>}

<a name="tzff-1678568020093"></a>**6.2.2 BFS（出队列将关联节点压队列）**

<a name="6ghi-1678812843788"></a>广度优先搜索（Breadth First Search ）

<a name="yxtm-1678812916063"></a>**-代码类似树的层序遍历，将选中的元素压队，出队时将图相连的元素入队。**

<a name="06mk-1684180430394"></a><a name="6fdp-1684180430795"></a>**6.2.3 为什么需要两种遍历**

<a name="dwfj-1684180472085"></a>**-迷宫出口靠近左上角--广度优先高效 ，圆圈型遍历**

<a name="ybea-1684180535099"></a>**-迷宫出口在右下角--深度有限高效，横向型遍历**

<a name="1ruv-1684355826515"></a><a name="ndxx-1684356076304"></a>-----伪代码逻辑分析思路---------

<a name="f6be-1684355826642"></a>**6.2.4 图连不通怎么办**

<a name="ivj5-1684355845184"></a>**6.2.5 拯救007** 

<a name="xria-1684355871851"></a>**6.2.6 六度空间理论 BFS**


<a name="kbqz-1684356072243"></a><a name="z5oh-1678813029755"></a><a name="1luf-1677788272945"></a>**11.1.2 散列表**

<a name="fb0g-1648371904573"></a>**-散列思想：**

<a name="ffdy-1648371914096"></a>**1.哈希函数计算出对应的函数值（数字），作为对象的存储地址。**

<a name="2now-1648371957139"></a>**2.可能不同的函数值会映射到同一个散列地址上，需要某种解决冲突的策略**

<a name="1yus-1648371855509"></a><a name="phu8-1677788272946"></a>**11.4 散列表的性能分析**

<a name="rey6-1648371277368"></a>**-事件复杂度O(1)**

<a name="9ip2-1699837592663"></a>选择合适的散列函数**hash(key**), 散列法的查找效率期望是常数**O(1)**, 几乎与关键字的空间的大小n无关！也适合关键字直接比较计算量大的问题

<a name="kxlv-1648371403694"></a>**-负载因子/装填因子(0.5<n<0.85)**

<a name="3544-1699837606275"></a>它是以较小的**负载因子（装填因子**）为前提。**空间换时间 0.5<n<0.85  hashmap 负载是0.75**

<a name="nuwh-1648371448540"></a>**-随机查找**

<a name="9f0r-1699837630771"></a>存储对关键字是**随机**的，不便于**顺序查找**关键字，也不适合**范围查找**，或**最大最小值**查找。

<a name="9cz3-1648371607274"></a>**-hash冲突解决**

<a name="qsys-1648371608637"></a>**1.开放地址法：**

<a name="jrve-1648371617660"></a>基于数组，存储效率高，随机查找

<a name="jsyj-1648371638132"></a>缺点是有聚集现象。

<a name="3seq-1648371648874"></a>**2.分离链接法：HashMap**

<a name="fqzm-1648371667117"></a>数组 + 链表（处理冲突）  链表查找效率长则查找性能降低

<a name="acwi-1648371712315"></a>key删除不需要“懒惰删除（逻辑删除）”法，没有储存垃圾

<a name="3zk0-1648371756660"></a>太小的负载可能导致空间浪费，大的负载因子又付出更多的时间代价。不均匀的链表长度导致时间效率严重下降。　　　

<a name="084u-1677788272947"></a>**9.1.1排序算法**

<a name="9j7c-1646750840050"></a>万级数量单位

<a name="g3wd-1677788272948"></a>**9.1.2 冒泡排序(每轮最大往前冒泡)**

<a name="ycob-1646749392231"></a>每轮找最大排此轮最后

<a name="2kyt-1646748676474"></a>for (int i = 0; i<lenght-1; i++)   //从零开始增加好像条件确实不美观，且有点难读  

<a name="pqzw-1646749051364"></a>for (int j = i; j<length-1-i;j++)

<a name="cmgz-1646749461592"></a>int changeCount = 0;

<a name="ndbb-1646749170023"></a>if ( int[j] > int[j] )

<a name="7jdh-1646749314167"></a>temp = int[j+1];

<a name="vw1v-1646749276604"></a>int[j+1] = int[j];

<a name="rhif-1646749304964"></a>int[j] = tmp;

<a name="bbcz-1646749480727"></a>changeCount ++;

<a name="k9mc-1646749508648"></a>if (changeCount==0) //当没有换位时，则排序完成。终止循环

<a name="o7jq-1646749526755"></a>break;  //continue--跳出本次循环，break跳出本层循环。跳出方法循环不可能用return，如果还有逻辑要处理;

<a name="kczp-1646748639611"></a><a name="guzd-1646751718765"></a>官方yyds BubbleSort

<a name="9zt9-1646750905858"></a>for( p=length-1; p>0; p--)

<a name="xtck-1646751245070"></a>flag = 0;

<a name="07dk-1646750494632"></a>for(int i=0; i<p; i++)  // 两头相交可减少变量复杂度

<a name="ebji-1646750782184"></a>if ( A[i] > A[ i+1])   // 稳定性-相等元素位置不会互换

<a name="ntsl-1646750812083"></a>  swap(A[i] ，A[i+1])

<a name="ito4-1646750437584"></a>  flag = 1;

<a name="2hjc-1646751278160"></a>if ( flag == 0) break;

<a name="ibqd-1646751892590"></a><a name="i0gw-1677788272949"></a>**9.1.3 插入排序(打牌)**

<a name="q9ob-1646759162627"></a>insertionSort

<a name="yzeo-1646751913410"></a> 打牌排序一样 [3,2,4,3]

<a name="k1wo-1646753220266"></a>for ( p=1; p<length; p++)

<a name="zwvx-1646756791554"></a>temp = A[p];

<a name="8spb-1646755578840"></a>for (i=p-1; i>=0;i--)

<a name="m7re-1646756043017"></a>if (A[i] > temp])

<a name="0gz5-1646756197367"></a>break;

<a name="3y8n-1646756728871"></a>swap(A[i],A[p]);

<a name="0332-1646753293785"></a>)

<a name="uxd3-1646758032857"></a>上面算法非最优，最好最坏都是O n平方，但是打牌经验来说，应该可以O(n)就可以的

<a name="6wup-1646758089879"></a>优化：

<a name="zgge-1646758092838"></a>for ( p=1; p<length; p++)

<a name="yxgt-1646758627541"></a>if (A[p-1] > =A[p]])  //和内循环跳出条件一样，可省略

<a name="ujn4-1646758109177"></a>continue;        

<a name="sufe-1646758642892"></a>temp = A[p];    //循环里面要注意变与不变,被改变下标的值需赋值临时变量做定值。

<a name="8j9o-1646758109173"></a>for (i=p-1; i>=0;i--)

<a name="wpm4-1646758759989"></a>if (A[i] >= temp)  //以后看到break前面没有执行代码的写法，这些跳出循环的条件都可以取反放在for条件里

<a name="i3lp-1646758763294"></a>break;

<a name="4lgr-1646758109179"></a>swap(A[i],A[i+1]); //上面已有temp，无需再浪费方法里的temp

<a name="5w9l-1646758109181"></a><a name="ir70-1646759702479"></a>根据官方再优化上面例子（代码优化 官方yyds）

<a name="udyj-1646759716291"></a>for ( p=1; p<length; p++)

<a name="oykl-1646759728496"></a>temp = A[p];  

<a name="cp86-1646759728498"></a>for (i=p-1; i>=0 && a[i]<temp;i--)    

<a name="t9fr-1646759728500"></a>a[i+1] = a[i] ;

<a name="m3hj-1646760141037"></a>a[i] = temp;  

<a name="7mkr-1646759728505"></a><a name="baun-1646759347191"></a>官方

<a name="njsd-1646759406469"></a>for ( p=1; p<length; p++)　

<a name="uznr-1646759430639"></a>    temp = a[p];

<a name="serm-1646759478901"></a>    //摸下一张牌

<a name="hep7-1646759489332"></a>for ( i=p; i >0 && a[i-1]>temp; i--)

<a name="nxda-1646759576564"></a>a[i] = a[i-1]; //移出空位

<a name="tgeq-1646759632467"></a>a[i] = temp; //新牌落位

<a name="mwai-1677718024582"></a><a name="7n4a-1677788272950"></a>**9.1.3.1 快速排序(分治算法)**

<a name="evi5-1699837774968"></a> **-递归的两个条件：**

<a name="v1wk-1699837806719"></a>**1.基线条件** 

<a name="ccbf-1699837837267"></a> **2.递归条件**

<a name="s5pr-1699837813602"></a>**-分治**

<a name="ns0a-1699837828819"></a>**1.找到基准值** 

<a name="uoqo-1699837831242"></a>**2.将问题切割成相同的小块，逐个解决** 

<a name="w6tb-1699837833288"></a>**3.将结果合并**

// 分治算法（与动态规划的区别？） 动态规划和分治法都是利用分治思想，不同点在于动态规划适用于子问题

有重叠的情况，而分治算法适用于子问题相互独立的情况

// java是根据下面的思想实现，由于java数组操作元素不变而变形

//  递归的两个条件：1.基线条件  2.递归条件

//1.找到基准值 2.将问题切割成相同的小块，逐个解决 3.将结果合并

def quicksort(array)；

`    `if len(arr) < 2;

`    `return arry; // 基线条件，为空或只包含一个元素则为有序

`     `else:

`         `pivot = array[0]

`         `less = [ i for i in array[l:] if i <= pivot] //由所有小于基数组成的数组

`         `greater = [ i for i in array[l:] if i > pivot] // 所有大于基数组成的数组

`         `return quicksort(less) + pivot + qicksort(greater) 

<a name="z0gn-1677718115276"></a>快排和归并都属于分治算法

<a name="iv9p-1646827663132"></a><a name="nlyn-1677788272951"></a>**9.1.4 时间复杂度下界(逆序对)**

<a name="ezs9-1646827707722"></a>**-逆序对  ，冒泡和插入每次交换只能消除一个逆序对！**

<a name="pwfg-1646827757191"></a>一次消掉好几个逆序对，效率就上来了

<a name="suoz-1646827870918"></a>**-定理： 任意N个不同元素组成的序列平均具有 N（N-1）/4 个逆序对。**

<a name="kfzn-1646827928434"></a>仅交换相邻两元素来排序的算法，其平均时间复杂度为 欧米伽（n平方）

<a name="gxb6-1646827996642"></a><a name="6yzg-1677788272952"></a>**9.2 希尔排序**

<a name="11np-1646828014825"></a>5-间隔排序    --1,6,11   2,7,12  3,8 4,9  5,10进行插入排序 一次交换尽可能消掉多的逆序对

<a name="cbkr-1646828127372"></a>3-间隔排序1,4,7   2,5,8  3,9,12  4,7,11进行插入排序

<a name="ydig-1646828132633"></a>1-间隔排序1,2 3,4.......  注**意： 间隔排序后，上一次间隔排序位置 值，仍是有序的**

<a name="2djc-1646828234073"></a><a name="8ruo-1646828251881"></a>定义增量序列 Dm...... = 1

<a name="up3u-1646828234725"></a>对每个Dk 进行Dk间隔 排序  k=m,m-1,....1

<a name="iso6-1646828321425"></a>**注意： 间隔排序后，上一次间隔排序位置 值，仍是有序的**

<a name="vgms-1646828415923"></a><a name="7tco-1646828432739"></a>原始希尔排序

<a name="shwl-1646828670367"></a>Dm = N/2Dk = Dk+1 / 2

<a name="5in9-1646828715240"></a>void Shell\_sort ( ElementType a[], int n) { 

<a name="38f5-1646828903475"></a>for ( d=n/2; d>0; d/2) {  //希尔增量序列

<a name="kndv-1646829063945"></a>for ( p = d; p<n; p++ ){

<a name="5z25-1646830022412"></a>tmp = a[p];

<a name="k7iy-1646830098573"></a>for ( i=p; i>d && a[i-d] > tmp; i-=d )  // ....我只能说牛逼

<a name="ngit-1646830625940"></a>a[i] = a [i-d];

<a name="nd5o-1646831070276"></a>a[i] = tmp;

<a name="dna6-1646830023608"></a>} 

<a name="eqzl-1646829064735"></a>}

<a name="4ye5-1646828904076"></a>}

<a name="e3cs-1646831123071"></a>增量元素不互质（没有公因子），而小增量可能根本不起作用。最坏情况1间隔才进行交换，变成了插入排序

<a name="yxbg-1646831333268"></a>更多增量序列：  Hibbard 增量序列   

<a name="kao3-1646831424850"></a>Sedgewick 增量序列

<a name="rqvm-1646831466003"></a>两个复杂度分析非常难。。。。

<a name="q9xc-1677788272953"></a>**9.3.1 选择排序**

<a name="dykg-1677788272954"></a>**9.3.2 堆排序**

<a name="bdrs-1646914055373"></a>void Heap\_Sort ( ElementType a[] ,int n) {

<a name="nwb2-1646914498736"></a>for ( i=n/2; i>=0; i --)  //buid heap

<a name="2oqf-1646914738389"></a>PercDown (a, i, n);

<a name="t17s-1646914757836"></a>forf (i = N-1; i>0; i--){

<a name="78ra-1646914782284"></a>Swap ( &a[0], &a[i]);  //deleteMax

<a name="6qdk-1646914847815"></a>percDown( a, 0, i);

<a name="ywf0-1646914783206"></a>}

<a name="8ou5-1646914499237"></a>}

<a name="igou-1646914876173"></a>定理： 堆排序处理N个不同元素的随机排列的平均比较次数是

<a name="yl0h-1646914937774"></a>2NlogN - O(Nlog logN)

<a name="nxiv-1646914954601"></a><a name="yhil-1646914956045"></a>虽然堆排序给出最佳平均时间复杂度，但实际效果不如用SedgeWick增量序列的希尔排序


<a name="fvo2-1646914932540"></a><a name="6n7y-1677788272970"></a><a name="kesf-1677788272955"></a>**leetcode**

<a name="aidz-1677788272956"></a>**1190 反转字符串**

<a name="xuzj-1647484550646"></a>**用的临时变量越多，越可能先入陷阱 （满足数据结构使用特性的，考虑用数据结构）**

<a name="aip8-1647484571160"></a>用两个堆栈可以搞定。（**进入层级（括号），嵌套/递归（保存上一层级的临时变量），用堆栈实现**。括号外相当于已反转再用一个堆栈保存（这是我没想到的）。）

<a name="nsgm-1670546069709"></a>头插法搞定：

<a name="9gw6-1653317410654"></a><a name="5npw-1677788272957"></a>**BM8  链表中倒数第N个节点 easy**

<a name="0dul-1653317466592"></a>要点，用快慢指针/双指针，先让快指针先跑（for），后同时跑(while)（可以省略单个while判断长度）。

<a name="ayot-1653317529216"></a>用计算数学法也可以。

<a name="gmzl-1677788272958"></a><a name="yt1h-1677788272959"></a>**BM15 删除有序链表中重复的元素-I      easy**

<a name="hxp1-1653495621632"></a>要考虑头尾/边界问题    。 注重的是 cur 和 next;
